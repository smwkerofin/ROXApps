<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
  <head>
    <!-- $Id: rox-clib.html,v 1.17 2004/10/23 11:39:35 stephen Exp $ -->
    <title>ROX-CLib</title>
  </head>

  <body>
    <h1>ROX-CLib</h1>

    <p>A library for ROX applications written in C.

    <h2>For Users</h2>

    <h3>Installation</h3>
    <p>Copy to a suitable place such as <samp>~/lib</samp> 
      or make sure it is on 
      your <samp>$LIBDIRPATH</samp>.
  If you use 
<a href="http://rox.sourceforge.net/phpwiki/index.php/Archive">Archive</a>
to extract it from then downloaded archive then make sure you rename
	it
to <code>ROX-CLib</code>.

    <p>Compile using <samp>ROX-CLib/AppRun --compile</samp>
 or running ROX-CLib from the filer.

<p>You will need 
GTK+ 2.x, 
libxml 2.4.x 
and GNU <code>make</code>.  Linux users should 
already have GNU make installed <code>/usr/bin</code>.  Other OS's may require you
use a different directory (<code>/usr/bin/local</samp>) or program name (<code>gmake</code>).
Set the environment variable MAKE to the correct value before
compiling, e.g.
<pre>
$ MAKE=gmake ROX-CLib/AppRun --compile
</pre>

    <h2>For Programmers</h2>

    <h3>Compiling and linking against the library</h3>

<p>Compile the library first

<p>Copy the <a href="libdir.html">libdir</a> script from 
<samp>ROX-CLib/<var>$PLATFORM</var>/bin/libdir</samp>
into your app dir.


<p>Add the output of
    <pre>   ROX-CLib --cflags</pre>
to your compile line, e.g.
<pre>   ROX_CLIB="`$APP_DIR/libdir ROX-CLib`/AppRun"</pre>
    <pre>   gcc `$ROX_CLIB --cflags` -c main.c </pre>

<p>You should include the main file:
<pre>
   #include &lt;rox/rox.h&gt;
</pre>
and any of the others you need.

<p>Add the output of
<pre>   ROX-CLib --cflags
   ROX-CLib --libs</pre>
to your link line, e.g.
<pre>   ROX_CLIB="`$APP_DIR/libdir ROX-CLib`/AppRun"</pre>
    <pre>   gcc `$ROX_CLIB --cflags` -o main main.o `$ROX_CLIB --libs`</pre>

<p>If you are using autoconf and building a ROX program then:
<ul>
<li>Copy ROX-CLib/Help/aclocal.m4 to your programs src directory.
<li>In src/configure.in add:
<pre>ROX_CLIB(2, 0, 0)</pre>

<li>In src/Makefile.in add:
<pre>  ROX_CLIB = @ROX_CLIB_PATH@/AppRun</pre>
    and to CFLAGS add: <samp>`${ROX_CLIB} --cflags`</samp>
    and to LDFLAGS add: <samp>`${ROX_CLIB} --libs`</samp>

<li>In AppRun (and AppletRun if it is an applet) ensure you have:
<pre>
   APP_DIR=`dirname $0`
   APP_DIR=`cd $APP_DIR;pwd`; export APP_DIR
   if [ -z "$LD_LIBRARY_PATH" ]; then
       LD_LIBRARY_PATH=`$APP_DIR/libdir ROX-CLib --runtime`
   else
       LD_LIBRARY_PATH=`$APP_DIR/libdir ROX-CLib --runtime`:$LD_LIBRARY_PATH
   fi
   export LD_LIBRARY_PATH
</pre>

</ul>

<h3>Zero Install</h3>

<p>To use ROX-CLib through Zero Install change the use of <a href="libdir.html">libdir</a> to:
<pre>    ROX_CLIB="`$APP_DIR/libdir --0install www.kerofin.demon.co.uk ROX-CLib`/AppRun"</pre>

    <h3>Library reference</h3>

    <p>Organized by header file.  Last updated for version 2.1.2. Use
			    as e.g.
<pre>
#include &lt;rox/rox.h&gt;
#include &lt;rox/rox_soap.h&gt;
</pre>

    <ul>
      <li><a href="#rox.h">rox.h</a></li>
      <li><a href="#choices.h">choices.h</a></li>
      <li><a href="#error.h">error.h</a></li>
      <li><a href="#gtksavebox.h">gtksavebox.h</a></li>
      <li><a href="#infowin.h">infowin.h</a></li>
      <li><a href="#rox_debug.h">rox_debug.h</a></li>
      <li><a href="#rox_dnd.h">rox_dnd.h</a></li>
      <li><a href="#rox_path.h">rox_path.h</a></li>
      <li><a href="#rox_resources.h">rox_resources.h</a></li>
      <li><a href="#rox_soap.h">rox_soap.h</a></li>
      <li><a href="#rox_filer_action.h">rox_filer_action.h</a></li>
      <li><a href="#applet.h">applet.h</a></li>
      <li><a href="#rox_soap_server.h">rox_soap_server.h</a></li>
      <li><a href="#options.h">options.h</a></li>
      <li><a href="#basedir.h">basedir.h</a></li>
      <li><a href="#mime.h">mime.h</a></li>
      <li><a href="#appinfo.h">appinfo.h</a></li>
      <li><a href="#mime_handler.h">mime_handler.h</a></li>
      <li><a href="#uri.h">uri.h</a></li>
    </ul>

    <h4><a name="rox.h">rox.h</a></h4>

    <p>Top level include.  It includes:
    <ul>
      <li> <a href="#choices.h"> choices.h</a></li>
      <li> <a href="#options.h"> options.h</a></li>
      <li><a href="#error.h">  error.h</a></li>
      <li> <a href="#rox_debug.h"> rox_debug.h</a></li>
      <li> <a href="#rox_resources.h"> rox_resources.h</a></li>
      <li> <a href="#infowin.h"> infowin.h</a></li>
    </ul>

    <p>Six functions are declared:

    <dl>
      <dt>
	<code>void rox_init(const char *program, int *argc, char ***argv)</code>
      <dd><p>

	  This handles the initialization of the library.  It calls:
	</p>
        <ul>
          <li><code>gtk_init(argc, argv)</code>
          <li><code>rox_debug_init(program)</code>
          <li><code>choices_init()</code>
          <li><code>options_init(program)</code> (if it detects an
					      $APP_DIR/Options.xml file)
          <li><code>rox_dnd_init()</code>
          <li><code>mime_init()</code>
        </ul>

      <dt>
	<code>const gchar *rox_get_program_name(void);</code>
      <dd><p>

	  Returns the program name, as passed to rox_init().  If
					      rox_init() was not
					      called then it returns NULL.
	</p>

      <dt>
	<code>const gchar *rox_get_app_dir(void);</code>
      <dd><p>

	  Returns the program's application directory, the environment
				      variable APP_DIR.  If
					      APP_DIR is not defined 
				      then it returns NULL.
	</p>

      <dt>
	<code>GdkPixbuf *rox_get_program_icon(void);</code>
      <dd><p>

	  Returns the program icon, loaded from the file .DirIcon in
					      the application
					      directory. If there is
					      no icon then NULL is returned.
	</p>

      <dt>
	<code>int rox_clib_version_number(void)</code>
      <dd><p>

	  Returns the version number of the library, so that 1.2.3 is encoded as 10203.
	</p>

      <dt>
	<code>const char *rox_clib_version_string(void)</code>

      <dd><p>
	  Returns a string of the version number of the library, in the form
	  "x.y.z (nth month year)" (actually the contents of the
						      Version tag in
						      the AppInfo.xml file).
	</p>

      <dt>
	<code>int rox_clib_gtk_version_number(void)</code>
      <dd><p>

	  Returns the version number of the GTK+ library ROX-CLib is
	  linked against, so that 1.2.3 is encoded as 10203.
	</p>

      <dt>
	<code>const char *rox_clib_gtk_version_string(void)</code>

      <dd><p>
	  Returns a string of the version number of the GTK+ library
	  ROX-CLib is 
	  linked against.
	</p>

      <dt>
	<code>void rox_add_window(GtkWidget *window)</code>

      <dd><p>
	  Registers the window with the window counting system.  When
									  the
window is destoyed it will automatically be de-registered.
	</p>

      <dt>
	<code>int rox_get_n_windows(void)</code>

      <dd><p>
	  Returns the number of windows registered.
	</p>

      <dt>
	<code>void rox_mainloop(void)</code>

      <dd><p>
	  This behaves as <code>gtk_main()</code>, except that it
will return when the number of registered windows reaches zero.  If
there are no registered windows when called it will return
										  immediately.
(Opening an options window via <code>options_show()</code> registers
a window).
	</p>
    </dl>

<h4><a name="choices.h">choices.h</a></h4>
    <p>Interface to the choices system and $CHOICESPATH.  Originally by 
      <a href="mailto:tal197@users.sourceforge.net">Thomas Leonard</a> and
      taken from the ROX-Filer source.

<p>If the environment variable <samp>ROX_USE_XDG_DIRS</samp> is set
				    and is 1, "yes" or "true" then the
				    XDG Basedir spec is used instead.</p>

    <dl>
      <dt>
	<code>void choices_init(void)</code>

      <dd><p>Must be called before the other choices_* calls.</p>

      <dt>
	<code>GPtrArray *choices_list_dirs(const char *<var>dir</var>)</code>

<dd><p>Returns an array of the directories in CHOICESPATH which contain
	  a subdirectory called '<var>dir</var>'.  The result should be freed by passing it
	  to <code>choices_free_list()</code></p>

      <dt>
	<code>void choices_free_list(GPtrArray *<var>list</var>)</code>

      <dd><p>Frees the list returned by <code>choices_list_dirs()</code></p>

      <dt>
	<code>gchar *choices_find_path_load(const char *<var>leaf</var>, const char *<var>dir</var>)</code>

<dd><p>Get the pathname of a choices file to load. Eg:

	<code>choices_find_path_load("menus", "ROX-Filer")</code>
	-> <samp>"/usr/local/share/Choices/ROX-Filer/menus"</samp>.

<p>The return values may be NULL - use built-in defaults - otherwise
	  <code>g_free()</code> the result.</p>

      <dt>
	<code>gchar *choices_find_path_save(const char *<var>leaf</var>, const char *<var>dir</var>, 
	  gboolean <var>create</var>)</code>

<dd><p>Returns the pathname of a file to save to, or NULL if saving is
	  disabled. If <var>'create'</var> is TRUE then intermediate directories will
be created (set this to FALSE if you just want to find out where
a saved file would go without actually altering the filesystem).

	<p><code>g_free()</code> the result.</p>

</dl>


    <h4><a name="error.h">error.h</a></h4>

    <p>Reporting errors.

    <dl>
      <dt><code>void rox_error(const char *<var>fmt</var>, ...)</code>

    <dd><p>Generates a string according to a printf style formatting
      string and supplied 
      args, then displays the string in a dialog window with the title
      "Error!" and 
      an OK button.
    </dl>

    <h4><a name="gtksavebox.h">gtksavebox.h</a></h4>

<p>Simple RISC OS style save box.

<p>GtkSaveBox is a GTK+ widget, derived from GtkWindow.  Originally by 
      <a href="mailto:tal197@users.sourceforge.net">Thomas Leonard</a> and
      taken from the ROX-Filer source.

    <dl>
      <dt>Functions
      <dd>
	<dl>
	  <dt><code>GtkWidget* gtk_savebox_new(void)</code>
	  <dd><p>Creates the GtkSaveBox widget.</p>

	  <dt><code>void gtk_savebox_set_icon(GtkSavebox *<var>savebox</var>,
	      GdkPixmap *<var>pixmap</var>, 
	      GdkPixmap *<var>mask</var>)</code>
	  <dd><p>Sets the icon that may be dragged about.</p>

	  <dt><code>void gtk_savebox_set_pathname(GtkSavebox
	      *<var>savebox</var>, gchar *<var>pathname</var>)</code> 
	  <dd><p>Sets the pathname in the entry box.</p>
	</dl>

      <dt>Types
      <dd>
	<dl>
	  <dt><code>enum {
  GTK_XDS_SAVED,
  GTK_XDS_SAVE_ERROR,
  GTK_XDS_NO_HANDLER,
}</code>
	  <dd><p>Used by the <code>save_to_file</code> signal:
	    <table>
 <tr><td>GTK_XDS_SAVED</td> <td>Done the save - no problem</td></tr>
 <tr><td>GTK_XDS_SAVE_ERROR</td><td> Error during save - reported</td> </tr>
 <tr><td>GTK_XDS_NO_HANDLER</td> <td>Used internally (sanity checking)</td> </tr>
	      
	    </table>

	</dl>

      <dt>Signals
      <dd>
	<dl>
	  <dt><code>gint save_to_file(GtkSavebox *<var>savebox</var>,
	      const gchar *<var>pathname</var>)</code> 
	  <dd><p>Save the data to disk using this pathname. Return 
	      <code>GTK_XDS_SAVED</code>
	      on success, or <code>GTK_XDS_SAVE_ERROR</code> on
	      failure (and report the error 
	to the user somehow). DO NOT mark the data unmodified or change
	the pathname for the file - this might be a scrap file transfer.
	    </p>

	  <dt><code>void saved_to_uri(GtkSavebox *<var>savebox</var>, 
	      const gchar
	      *<var>uri</var>)</code>

	  <dD><p> The data is saved. If '<var>uri</var>' is non-NULL, mark the file as unmodified
 and update the pathname/uri for the file to the one given.</p>

	</dl>
    </dl>

    <h4><a name="infowin.h">infowin.h</a></h4>

    <p>RISC OS style information window.

    <p>ROXInfoWin is a GTK+ widget, derived from GtkDialog.  
<strong>Changed in ROX-CLib 2.1.2:</strong> InfoWin was renamed
				  ROXInfoWin and the functions renamed
				  accordingly.  Functions remain
				  available under the old names for
				  binary compatability, but should not
				  be used in new code.
    <dl>
      <dt>Functions
      <dd>
	<dl>
	  <dt><code>GtkWidget* rox_info_win_new(const gchar *<var>program</var>, 
	      const gchar *<var>purpose</var>,
	      const gchar *<var>version</var>, const gchar *<var>author</var>,
	      const gchar *<var>website</var>)</code>

	    <dd><p>Create a new ROXInfoWin object.  The data in the
	      window is taken from the function arguments.
			<code>rox_info_win_new_from_appinfo</code> is prefered.</p>

	  <dt><code>GtkWidget* rox_info_win_new_from_appinfo(const gchar *<var>program</var>)</code>

	    <dd><p>Create a new ROXInfoWin object.  The data in the
	      window is taken from the file $APP_DIR/AppInfo.xml, if
							    it exists.</p>

	  <dt><code>void rox_info_win_add_browser_command(ROXInfoWin *<var>iw</var>, 
	      const gchar *<var>cmd</var>)</code>

	  <dd><p>Adds a command which will visit a named web site.
	      The command will be called with a single argument, the
	      URL passed in <code>rox_info_win_new()</code> or defined
					in $APP_DIR/AppInfo.xml. 
	    </p>
<p><strong>Deprecated</strong>, ROXInfoWin now uses 
<a href="#rox_uri_launch">rox_uri_launch()</a>  which relies on the 
handler for the text/x-uri MIME type.

	  <dt><code>GtkWidget* info_win_new(const gchar *<var>program</var>, 
	      const gchar *<var>purpose</var>,
	      const gchar *<var>version</var>, const gchar *<var>author</var>,
	      const gchar *<var>website</var>)</code>

	    <dd><p><strong>Deprecated.</strong>  Use 
<code>rox_info_win_new_from_appinfo()</code> instead.  This is the
							    same
as that, except that the new window is persistant: when closed it
is hidden, not destroyed.</p>

	  <dt><code>GtkWidget* info_win_new_from_appinfo(const gchar *<var>program</var>)</code>
	    <dd><p><strong>Deprecated.</strong>  Use 
<code>rox_info_win_new_from_appinfo()</code> instead. This is the
							    same
as that, except that the new window is persistant: when closed it
is hidden, not destroyed</p>


	  <dt><code>void info_win_add_browser_command(ROXInfoWin *<var>iw</var>, 
	      const gchar *<var>cmd</var>)</code>

	    <dd><p><strong>Deprecated.</strong>

	</dl>

      <dt>Signals
      <dd><p>None.</p>
    </dl>

    <h4><a name="rox_debug.h">rox_debug.h</a></h4>


    <p>Utilities for generating debug output.  Unless the pre-processor symbol 
      <code>DEBUG</code> is defined and non-zero before rox_debug.h is
      included then nothing  is declared.

    <dl>
      <dt>
	<code>void rox_debug_init(const char *<var>progname</var>)</code>

      <dd><p>
	  Initialises the debug system.  <var>progname</var> is the
	  name of the program which will  
	  prefix the output.  Should be called at start, if not (or
	  <var>progname</var>==NULL)  
	  then <var>progname</var> is assumed to be "ROX".</p>

      <dt>
	<code>void rox_debug_printf(int <var>level</var>, 
	  const char *<var>format</var>, ...)</code>

	<dd><p>Sends a debug message, using glib's <code>g_logv</code>.  <var>level</var> is the level of severity
and should be in the range 0-5, with 0 most severe.  The user controls the
	amount of output by setting the environment <var>PROGNAME_DEBUG_LEVEL</var> to the
maximum severity to display.<p>

      <dt>
	<code>#define dprintf rox_debug_printf</code>

      <dd><p>Aliases <code>dprintf</code> as <code>rox_debug_printf</code></p>
    </dl>

    <h4><a name="rox_dnd.h">rox_dnd.h</a></h4>


<p>Utilities to simplify the handling of drag and drop for the client.
Based on the ROX-Filer code written by
<a href="mailto:tal197@users.sourceforge.net">Thomas Leonard</a>

<dl>
<dt><code>typedef gboolean (*rox_dnd_handle_uris)(GtkWidget *widget,
					GSList *uris,
					gpointer data,
					gpointer udata)</code>

<dd><p>Type of function called when a widget registered with rox_dnd has a list
of URIs dropped on it. It should return TRUE if handled successfully, 
FALSE otherwise.</p>

<dt><code>typedef gboolean (*rox_dnd_handle_xds)(GtkWidget *widget,
					const gchar *path,
					gpointer data,
					gpointer udata)</code>

<dd><p>Type of function called when a widget registered with rox_dnd has a 
direct save on it. It should return TRUE if handled successfully, 
FALSE otherwise.</p>

<dt><code>void rox_dnd_init(void)</code>

<dd><p>Called to initialise rox_dnd, before any other call.</p>

      <dt><code>void rox_dnd_register_full(GtkWidget *<var>widget</var>,
	  guint <var>flags</var>,
	  rox_dnd_handle_uris <var>uris</var>,
	  rox_dnd_handle_xds <var>xds</var>,
	  gpointer <var>udata</var>)</code>

<dd><p>Registers a widget with rox_dnd to handle any drops on it.  There are no
	  flags defined yet, so <var>flags</var> must be set to zero.  <var>uris</var> handles URI list drops,
	  <var>xds</var> handles the XDirectSave protocol.  <var>udata</var>
is passed to the handler routine.</p>

      <dt><code>GSList *rox_dnd_filter_local(GSList *<var>uris</var>)</code>

<dd><p>Scans list of URIs and picks out only those that refer to local files.
Free result with rox_dnd_local_free().</p>

<dt><code>void rox_dnd_local_free(GSList *paths)</code>
<dd><p>Frees the data returned by rox_dnd_filter_local().</p>
</dl>

    <h4><a name="rox_path.h">rox_path.h</a></h4>

<p>Utilities for handling the URIs used in the drag & drop protocol.  All 
      returned strings should be passed to <code>g_free()</code> when done.

<dl>
      <dt><code>gchar *rox_path_get_local(const gchar *<var>uri</var>)</code>

<dd><p>Returns the local path of the URI if it refers to a local file: path, otherwise
it returns NULL.</p>

      <dt><code>gchar *rox_path_get_server(const gchar *<var>uri</var>)</code>

<dd><p>Returns the host part of the URI if it is a file: URI, otherwise
it returns NULL.</p>

      <dt><code>gchar *rox_path_get_path(const gchar *<var>uri</var>)</code>

<dd><p>Returns the path part of a file: URI regardless of whether it is the local
host or not.</p>

      <dt><code>int rox_hostname_is_local(const gchar *<var>hname</var>)</code>

<dd><p>Returns <code>TRUE</code> if the host name <var>hname</var> is one of 
the valid host names for the current machine.</p>

</dl>

    <h4><a name="rox_resources.h">rox_resources.h</a></h4>


<p>Utility functions for finding resource files, which may be locale specific.

<dl>
      <dt><code>gchar *rox_resources_find(const gchar *<var>app_name</var>,
	  const gchar *<var>leaf</var>,
	  const gchar *<var>lang</var>)</code>

      <dd><p>Search <code>$CHOICESPATH</code>, then
	  <code>$APP_DIR</code> for a directory called
	  <samp>Resources</samp> 
	  which contains the file <samp>leaf</samp>, whether in a
	  sub-directory <samp>lang</samp> or 
	  directly.  Returns the full path if found (pass to
	  <code>g_free</code> when done) 
	  or <code>NULL</code> if not.  lang may be
	  <code>ROX_RESOURCES_NO_LANG</code> to not search 
	  for sub-directories, or
	  <code>ROX_RESOURCES_DEFAULT_LANG</code> for the
	  sub-directory 
	  appropriate for the selected language.

	<p>If the language is set to <samp>en_GB.ISO8859-1</samp> then
	  the sub-directories tried are:
<ul>
	  <li><var>{Choices}</var>/<var>app_name</var>/en_GB.ISO8859-1/
	  <li><var>{Choices}</var>/<var>app_name</var>/en.ISO8859-1/
	  <li><var>{Choices}</var>/<var>app_name</var>/en_GB/
	  <li><var>{Choices}</var>/<var>app_name</var>/en/
	  <li><var>{Choices}</var>/<var>app_name</var>/
</ul>
in that order.</p>
</dl>

    <h4><a name="rox_soap.h">rox_soap.h</a></h4>

<p>Communicating with the filer via SOAP. 
Based on the ROX-Filer code written by
<a href="mailto:tal197@users.sourceforge.net">Thomas Leonard</a>

<dl>
      <dt><code>typedef struct rox_soap_filer ROXSOAP;</code>

      <dd><p>This is an opaque type representing the connection to an
	  instance of the filer.</p> 

      <dt><code>typedef void (*rox_soap_callback)(ROXSOAP *filer, 
	  gboolean status, 
	  xmlDocPtr reply, 
	  gpointer udata)</code>

      <dd><p>Defines the function called when the SOAP call completes.
	  If <var>status</var> is <code>FALSE</code>  
	  then the call failed and reply is <code>NULL</code>.  If
	  <var>status</var> is not <code>FALSE</code> then the call  
	  succeeded and <var>reply</var> contains the result (may
	  still be <code>NULL</code>). </p>

      <dt><code>void rox_soap_init(void);</code>
=09
      <dd><p>Initializes the data.</p>

      <dt><code>void rox_soap_define_program(const char
	  *<var>name</var>, 
	  const char *<var>atom_fmt</var>,
	  const char *<var>command</var>);</code>

      <dd><p>Define how to connect to the named program.
	  <table>
	    <tr><td><var>name</var></td>
	      <td>name of program as passed to rox_soap_connect</td></tr>
	    <tr><td><var>atom_fmt</var></td>
	      <td>format of atom name to use to connect, %e is effective UID,
		%h is FQDN of display</td></tr>
	    <tr><td><var>command</var></td>
	      <td>command that may be fed the SOAP document on stdin if
		connecting via the atom fails, may be NULL</td></tr>
	  </table>
	  
	<p>An entry for ROX-Filer is pre-defined. 
	  (<samp>"ROX-Filer"</samp>, 
	  <samp>"_ROX_FILER_%e_%h"</samp>,
	  <samp>"rox -R"</samp>).</p>

      <dt><code>char *rox_soap_atom_name_for_program(const char *
	  <var>name</var>);</code>

      <dd><p>Returns the name of the atom which will be used to locate the given program.
	  It uses the format given in the <code>rox_soap_define_program()</code> call, with the
	  defined substitutions.  Pass to <code>g_free()</code> when done.</p>

      <dt><code>gboolean rox_soap_ping(const char *<var>prog</var>);</code>

      <dd><p>Returns <code>TRUE</code> if the named program is contactable via SOAP.</p>

      <dt><code>ROXSOAP *rox_soap_connect(const char *<var>prog_name</var>);</code>

<dd><p>Initialise the connection to the named program.</p>

<dt><code>ROXSOAP *rox_soap_connect_to_filer(void);</code>

<dd><p>Initialise the connection to the filer.</p>

      <dt><code>gboolean rox_soap_send(ROXSOAP *<var>program</var>, 
	  xmlDocPtr <var>doc</var>, gboolean <var>run_prog</var>,
	  rox_soap_callback <var>callback</var>, 
	  gpointer <var>udata</var>);</code>

      <dd><p>Send the XML document to program using SOAP.  If
	  <var>run_prog</var> is <code>TRUE</code> 
	  and there is no program to talk to, use
	  <code>rox_soap_send_via_pipe()</code>. 
	  Returns <code>TRUE</code> if comms succeeded, when complete
	  <var>callback</var> is called with 
	  the status and reply.</p> 

      <dt><code>gboolean rox_soap_send_via_pipe(ROXSOAP *<var>filer</var>, 
	  xmlDocPtr <var>doc</var>, 
	  rox_soap_callback <var>callback</var>, 
	  gpointer <var>udata</var>);</code>


      <dd><p>Send the XML document to the program, using the command defined by
	  <code>rox_soap_define_program()</code>.  When complete
	  <var>callback</var> is called with the 
	  status and reply.</p>

      <dt><code>void rox_soap_set_timeout(ROXSOAP *<var>filer</var>, 
	  guint <var>ms</var>);</code>

      <dd><p>Set the timeout when contacting ROX-Filer (in ms,
	  defaults to 10000).  If 
	  filer is <code>NULL</code> it sets the timeout for all new
	  connections.</p> 

      <dt><code>xmlDocPtr rox_soap_build_xml(const char *<var>action</var>, 
	  const char *<var>ns_url</var>,
	  xmlNodePtr *<var>act</var>);</code>

      <dd><p>Build part of XML document to send.  The action to
	  perform is in name 
	  space <var>ns_url</var>.  Add arguments to the node
	  <var>act</var>, then call <code>rox_soap_send()</code> 
	  with the return value.</p>

      <dt><code>const char *rox_soap_get_last_error(void);</code>

      <dd><p>Returns the text of the last error raised.  This may be
	  <code>"No error"</code> if no error 
	  has occured, or <code>rox_soap_clear_error()</code> has been
	  called.</p> 

      <dt><code>void rox_soap_clear_error(void);</code>

      <dd><p>Clears the error text.</p>

      <dt><code>void rox_soap_close(ROXSOAP *<var>filer</var>);</code>

      <dd><p>Close connection.</p>
    </dl>

    <h4><a name="rox_filer_action.h">rox_filer_action.h</a></h4>

<p>These functions drive ROX-Filer via the rox_soap.h interface above.

<dl>
<dt><code>
typedef enum panel_side {
  ROXPS_TOP,ROXPS_BOTTOM,ROXPS_LEFT,ROXPS_RIGHT
} ROXPanelSide;</code>

<dd><p>The four possible places for a panel, used in rox_filer_panel().</p>

<dt><code>#define ROX_FILER_DEFAULT (-1)  </code>

<dd><p>This value means "use value user has selected in options".</p>

<dt><code>char *rox_filer_version(void);</code>

      <dd><p>Return the version string for the current filer.  Return
      value should be passed to g_free when done.</p>

      <dt><code>void rox_filer_open_dir(const char
      *<var>filename</var>);</code>

<dd><p>Open a viewer for the given directory.</p>

      <dt><code>void rox_filer_close_dir(const char *<var>filename</var>);</code>

<dd><p>Close all viewers for the given directory and any subdirectories.</p>

      <dt><code>void rox_filer_examine(const char *<var>filename</var>);</code>

<dd><p>Re-fresh the viewer for the given directory.</p>

      <dt><code>void rox_filer_panel(const char *<var>name</var>, ROXPanelSide <var>side</var>);</code>

      <dd><p>Open a panel with the given name on the specfied side.
      If <var>name</var> is "" then the panel on that side is closed
      instead.</p>

      <dt><code>void rox_filer_panel_add(ROXPanelSide <var>side</var>,
      const char *<var>path</var>, int <var>after</var>);</code>

      <dd><p>Add an object to the panel on the specfied side.  If
      <var>after</var> is <code>FALSE</code> then the object is placed
      on the left (top or bottom panels) or top (left or right
      panels), otherwise the other end.</p>

      <dt><code>void rox_filer_pinboard(const char *<var>name</var>);</code>

      <dd><p>Display pinboard name on the desktop background.
      <var>Name</var> can be a name in Choices (eg, `MyPinboard') or a
      full pathname.</p>

      <dt><code>void rox_filer_pinboard_add(const char
      *<var>path</var>, int <var>x</var>, int <var>y</var>);</code>

<dd><p>Add an object to the pinboard at the specfied co-ordinates. </p> 

      <dt><code>void rox_filer_run(const char *<var>filename</var>);</code>

      <dd><p>Run <var>filename</var> as if it was clicked on in the filer.</p>

      <dt><code>void rox_filer_show(const char *<var>directory</var>, const char *<var>leafname</var>);</code>

      <dd><p>Open <var>directory</var> and flash the file <var>leafname</var> inside it.</p>

      <dt><code>void rox_filer_copy(const char *<var>from</var>, 
	  const char *<var>to</var>,
	  const char *<var>leafname</var>, int <var>quiet</var>);</code>

      <dd><p>Copy the object <var>from</var> into the directory
      <var>to</var>.  If leafname is not <code>NULL</code> then use it
      as the new name of the file.  If <var>quiet</var> is
      <code>FALSE</code> then prompt the user before copying.</p>

      <dt><code>void rox_filer_move(const char *<var>from</var>, 
	  const char *<var>to</var>,
	  const char *<var>leafname</var>, int <var>quiet</var>);</code>

      <dd><p>Move the object <var>from</var> into the directory
      <var>to</var>.  If <var>leafname</var> is not <code>NULL</code>
      then use it as the new name of the file.  If <var>quiet</var> is
      <code>FALSE</code> then prompt the user before moving.</p>

      <dt><code>void rox_filer_link(const char *<var>from</var>, 
	  const char *<var>to</var>,
	  const char *<var>leafname</var>);</code>

      <dd><p>Symbolically link the object <var>from</var> into the
      directory <var>to</var>.  If <var>leafname</var> is not
      <code>NULL</code> then use it as the new name of the file.</p>

      <dt><code>void rox_filer_mount(const char *<var>mountpoint</var>,
	  int <var>quiet</var>, int <var>opendir</var>);</code>

      <dd><p>Attempt to mount on the directory <var>mountpoint</var>
      (which should be in <code>/etc/fstab</code> or similar).  If
      <var>quiet</var> is <code>FALSE</code> then prompt the user
      before mounting.  If <var>opendir</var> is not
      <code>FALSE</code> then open a viewer for the new directory if
      succesfully mounted.  The ability to mount is normally
      restricted.</p>

      <dt><code>char *rox_filer_file_type(const char *<var>file</var>);</code>

      <dd><p>Return a string describing the MIME type of the given
      <var>file</var> (which need not exist!).  Return value should be
      passed to <code>g_free</code> when done.  If <code>NULL</code>
      is returned then there was an error in communication.</p>

<dt><code>int rox_filer_have_error(void);</code>

<dd><p>Returns non-zero if an error message is available.</p>

<dt><code>const char *rox_filer_get_last_error(void);</code>

      <dd><p>Returns the text of the last error raised.  This may be
      <code>"No error"</code> if no error has occured, or
	  <code>rox_filer_clear_error()</code> has been called.</p>

<dt><code>void rox_filer_clear_error(void);</code>

<dd><p>Clears the error text.</p>
</dl>

    <h4><a name="applet.h">applet.h</a></h4>


<p>Utilities for developing ROX applets.

<dl>
<dt>
<code>typedef enum panel_location {
  PANEL_TOP, PANEL_BOTTOM, PANEL_LEFT, PANEL_RIGHT,
  PANEL_UNKNOWN
} PanelLocation;</code>

<dd><p>Defines the four possible locations for the panel containing the applet,
plus an error condition.</p>

<dt>
	<code>extern void applet_popup_menu(GtkWidget *<var>plug</var>, 
	  GtkWidget *<var>menu</var>, 
	  GdkEventButton *<var>evbut</var>);</code>

<dd><p>Shows a pop-up menu in a suitable place for the applet.  It is
assumed that this will be called in a <code>button_press</code>
handler which is passed a <code>GdkEventButton *</code>.
<var>plug</var> is the GtkPlug object which is the applets window.</p>

</dl>

    <h4><a name="rox_soap_server.h">rox_soap_server.h</a></h4>

<p>Provides a ROX-Filer like SOAP server.
Based on the ROX-Filer code written by
<a href="mailto:tal197@users.sourceforge.net">Thomas Leonard</a>

<dl>
<dt><code>typedef struct rox_soap_server ROXSOAPServer;</code>

<dd><p>This is an opaque object representing the server.</p>

<dt><code>typedef xmlNodePtr (*rox_soap_server_action)(ROXSOAPServer *server,
				       const char *action_name,
				       GList *args, gpointer udata);</code>

<dd><p>This represents the type of the function called when a SOAP
method is executed.  Any reply should be returned as an XML node.
<var>args</var> is a list of the arguments passed as XML nodes, in the
order they were defined in <code>rox_soap_server_add_action()</code>
(required, then optional).  Optional arguments may be
<code>NULL</code>.</p></dd>

<dt><code>typedef struct rox_soap_server_actions ROXSOAPServerActions;</code>
<dd><p>This type is used for an array of SOAP server actions to be 
passed to <code>rox_soap_server_add_actions()</code>.  It is
defined as:</p>
<code><pre>
typedef struct rox_soap_server_actions {
  const char *action_name;
  const char *args;
  const char *optional_args;
  rox_soap_server_action action;
  gpointer udata;
} ROXSOAPServerActions;
</pre></code>
</dd>

<dt><code>void rox_soap_server_init(void);</code>

<dd><p>Initialise the server routines.</p>

      <dt><code>ROXSOAPServer *rox_soap_server_new(
	  const char *<var>program_name</var>,
	  const char *<var>ns_url</var>);</code>

      <dd><p>Create a new server object and advertise it via the root
      window.  <var>program_name</var> is the name of the program (see
      <code>rox_soap_define_program()</code>).  <var>ns_url</var> is
      the name space URL.</p>

      <dt><code>void rox_soap_server_add_action(
	  ROXSOAPServer *<var>server</var>,
	  const char *<var>action_name</var>,
	  const char *<var>args</var>,
	  const char *<var>optional_args</var>,
	  rox_soap_server_action <var>action</var>,
	  gpointer <var>udata</var>);</code>

      <dd><p>Define a new method (or action) supported by this server.
      <var>action_name</var> is the name of the action.
      <var>args</var> is a string of a comma seperated list of
      arguments, or <code>NULL</code> if there are no required
      arguments.  <var>optional_args</var> is a string of a comma
      seperated list of arguments, or <code>NULL</code> if there are
      no optional arguments.  <var>action</var> is the function to
      call when a correctly formatted SOAP message is received.</p>

      <dt><code>void rox_soap_server_add_action(
	  ROXSOAPServer *<var>server</var>,
	  ROXSOAPServerActions *<var>actiona</var>);</code>

      <dd><p>Define a group of new methods (or actions) supported by this server.
      <var>actions</var> is the array of action definitions,
										      terminated by an entry with a 
										      <code>NULL</code> <var>action_name</var>.</p>

      <dt><code>void rox_soap_server_delete(
	  ROXSOAPServer *<var>server</var>);</code>

<dd><p>Shutdown the server and release its memory.</p>
</dl>

<h4><a name="options.h">options.h</h4>

<p>Options system for configuring your program, similar to ROX-Filer's
      options.
Based on the ROX-Filer code written by
<a href="mailto:tal197@users.sourceforge.net">Thomas Leonard</a>

<dl>
      <dt><code>typedef struct _Option Option;</code>

<dd><p>Object used to store an option.  The following members are used to access the
values:
<dl>
	  <dt><code>gchar *value</code>		
<dd><p>Value of the option, as a string</p>
	  <dt><code>long int_value</code>	
<dd><p>Value of the option, as a number</p>
	  <dt><code>gboolean has_changed</code>  
<dd><p>Non-zero if the option has changed (valid in the 
			OptionNotify callback).</p>
	  <dt><code>gchar	*backup;</code>	
<dd><p>Copy of value to Revert to </p>
</dl>

<dl>
<p>The other members are used when implementing new widget types.
      <dt><code>GtkWidget *widget;</code>	
<dd><p>Widget that stores the value</p>
      <dt><code>void (*update_widget)(Option *option);</code> 
<dd><p>Call to set value</p>
      <dt><code>gchar *(*read_widget)(Option *option);</code> 
<dd><p>Call to read value</p>
</dl>
</p>

      <dt><code>typedef void OptionNotify(void);</code>

<dd><p>Type of function called when options changed (see option_add_notify() below).
</p>

      <dt><code>typedef GList * (*OptionBuildFn)(Option *option, xmlNode *node, gchar *label);</code>

<dd><p>Type of function used to build widgets (see option_register_widget()
below) for the options window.  option is the option for which the
widget is used.  node is the XML node from the Options.xml file
describing the widget.  label is the label property from the element,
to be used as a label.  Returns a list of widgets to be added to the
window.
</p>

      <dt><code>void options_init(const char *project);</code>

<dd><p>Called to initialize options system.  Must be called after choices_init(), but 
before any other function in the options system.  project is the name of the 
project and is passed to choices functions.
</p>

      <dt><code>void option_register_widget(char *name, OptionBuildFn builder);</code>

<dd><p>Registers a new widget type.  name is the name of the XML element in the 
Options.xml file.  builder is the function used to build the widget.  
Pre-defined widget types include:
<ul>
	<li>label
	<li>spacer
	<li>frame
	<li>toggle
	<li>slider
	<li>entry
	<li>numentry
	<li>radio-group
	<li>colour
	<li>menu
	<li>font
</ul>
</p>

      <dt><code>void option_check_widget(Option *option);</code>

<dd><p>This is called when the widget's value is modified by the user.
Reads the new value of the widget into the option and calls
the notify callbacks.
</p>

      <dt><code>void option_add_int(Option *option, const gchar *key, int value);</code>

<dd><p>Adds a new option to hold integer values.
</p>

      <dt><code>void option_add_string(Option *option, const gchar *key, const gchar *value);</code>

<dd><p>Adds a new option to hold string values, including fonts and colours.
</p>

      <dt><code>void options_notify(void);</code>

<dd><p>Inform watching functions that options have changed.
</p>

      <dt><code>void option_add_notify(OptionNotify *callback);</code>

<dd><p>Add a callback to be called when options have changed.
</p>

      <dt><code>GtkWidget *options_show(void);</code>

<dd><p>Show options window.  Returns the window widget (you don't
normally need this), NULL if already open.

This causes the $APP_DIR/Options.xml file to be parsed.  This is an XML file containing
an 'options' element.  This in turn contains 1 or more 'section' element,
each with a 'title' property and containing one or more widgets to be built.
The 'section' elements can be nested.</p>

<p>Widgets available by default (see option_register_widget() for
	  more) are:
<dl>
  <dt><code>label help=int</code>
	<dd><p>A label</p>
  <dt><code>hbox [label=str]</code>
  <dt><code>vbox [label=str]</code>
  <dt><code>spacer</code>
  <dt><code>frame label=str</code>
	<dd><p>Container for other objects</p>
  <dt><code>section title=str</code>
	<dd><p>Groups options, can be nested.</p>

  <dt><code>toggle name=str label=str</code>
	<dd><p>Simple on/off switch</p>
  <dt><code>slider name=str label=str min=int max=int fixed=bool showvalue=bool [end=str]</code>
	  <dd><p>Range of ints.  <var>fixed</var> is fixed width.  If <var>showvalue</var> then current
	      value shown.  <var>end</var> is label after slider widget</p>
  <dt><code>entry name=str label=str</code>
	<dd><p>Text entry</p>
  <dt><code>numentry name=str label=str min=int max=int step=int width=int [unit=str]</code>
	  <dd><p>Numeric entry.  <var>width</var> is number of digits.  <var>unit</var> is text to right
	of widget (units indicator).</p>
  <dt><code>radio-group name=str label=str [columns=int]</code>
	<dd><p>List of exclusive options.  Must contain radio elements</p>
  <dt><code>radio label=str value=str</code>
	<dd><p>Option for a radio group</p>
  <dt><code>colour name=str label=str</code>
	<dd><p>Button for colour selector</p>
  <dt><code>menu name=str label=str</code>
	<dd><p>Option menu.  Must contain 'item' elements.</p>
  <dt><code>item label=str value=str</code>
	<dd><p>Option for an option menu</p>
  <dt><code>font name=str label=str override=int</code>
	  <dd><p>Button for font selector.  If <var>override</var>, adds a checkbox to enable the
	font.</p>
</dl>
</p>
<p>The new window is registered using <code>rox_add_window()</code>
</dl>

<h4><a name="basedir.h">basedir.h</a></h4>
    <p>Interface to the XDG Base directory system.

    <dl>


      <dt>
	<code>gchar *basedir_save_config_path(const char *<var>resource</var>, 
const char *<var>leaf</var>)</code></dt>

<dd><p>Returns the pathname of a configuration file to save. This will
be in the directory <code>$XDG_CONFIG_HOME</code> 
(defaulting to <samp>$HOME/.config</samp>). Eg:

	<code>basedir_save_config_path("MyApp", "options.dat")</code>
	-> <samp>"/home/myuser/.config/MyApp/options.dat"</samp>.</p>

<p>The directory <code>$XDG_CONFIG_HOME</code> and the sub-directory
<var>resource</var> are created by this call if required.</p>

<p>The parameter <var>leaf</var> may be <code>NULL</code>.  If so just
the directory part is returned.<p>

	<code>basedir_save_config_path("MyApp", NULL)</code>
	-> <samp>"/home/myuser/.config/MyApp"</samp>.</p>

<p>The return value may be NULL - saving is disabled - otherwise
	  <code>g_free()</code> the result.</p>
</dd>

      <dt>
	<code>gchar *basedir_save_data_path(const char *<var>resource</var>, 
const char *<var>leaf</var>)</code></dt>

<dd><p>Returns the pathname of a data file to save. This will
be in the directory <code>$XDG_DATA_HOME</code> 
(defaulting to <samp>$HOME/.local/share</samp>). Eg:

	<code>basedir_save_data_path("MyApp", "data.dat")</code>
	-> <samp>"/home/myuser/.local/share/MyApp/data.dat"</samp>.</p>

<p>The directory <code>$XDG_DATA_HOME</code> and the sub-directory
<var>resource</var> are created by this call if required.</p>

<p>The parameter <var>leaf</var> may be <code>NULL</code>.  If so just
the directory part is returned.<p>

	<code>basedir_save_data_path("MyApp", NULL)</code>
	-> <samp>"/home/myuser/.local/share/MyApp"</samp>.</p>

<p>The return value may be NULL - saving is disabled - otherwise
	  <code>g_free()</code> the result.</p>
</dd>

      <dt>
	<code>gchar *basedir_load_config_path(const char *<var>resource</var>, 
const char *<var>leaf</var>)</code></dt>

<dd><p>Returns the pathname of a configuration file to load. This will
be in the directory <code>$XDG_CONFIG_HOME</code> 
(defaulting to <samp>$HOME/.config</samp>) or a directory named in
<code>$XDG_CONFIG_DIRS</code>
(defaulting to <samp>/etc/xdg</samp>). Eg:

	<code>basedir_load_config_path("MyApp", "options.dat")</code>
	-> <samp>"/home/myuser/.config/MyApp/options.dat"</samp>.</p>

<p>The return value may be NULL - meaning the file was not found - otherwise
	  <code>g_free()</code> the result.</p>
</dd>

      <dt>
	<code>gchar *basedir_load_data_path(const char *<var>resource</var>, 
const char *<var>leaf</var>)</code></dt>

<dd><p>Returns the pathname of a data file to load. This will
be in the directory <code>$XDG_DATA_HOME</code> 
(defaulting to <samp>$HOME/.local/share</samp>) or a directory named in
<code>$XDG_DATA_DIRS</code>
(defaulting to <samp>/usr/local/share:/usr/share</samp>). 
Eg:

	<code>basedir_load_data_path("MyApp", "data.dat")</code>
	-> <samp>"/usr/local/share/MyApp/data.dat"</samp>.</p>

<p>The return value may be NULL - meaning the file was not found - otherwise
	  <code>g_free()</code> the result.</p>
</dd>

      <dt>
	<code>GList *basedir_load_config_paths(const char *<var>resource</var>, 
const char *<var>leaf</var>)</code></dt>

<dd><p>Returns a list of all the pathnames of existing configuration files to load. This 
includes the directories <code>$XDG_CONFIG_HOME</code> 
(defaulting to <samp>$HOME/.config</samp>) and
<code>$XDG_CONFIG_DIRS</code>
(defaulting to <samp>/etc/xdg</samp>). 

<p>If <var>leaf</var> is <code>NULL</code> then just the existing configuration
directories for <var>resource</var> are returned.  If
<var>resource</var>
is <code>NULL</code> then the existing configuration directories are returned.
</p>

<p>The return value may be NULL if no config directories or config files
could be found.  Otherwise <code>g_free()</code> each list item and
<code>g_list_free()</code> the whole list.</p>
</dd>

      <dt>
	<code>GList *basedir_load_data_paths(const char *<var>resource</var>, 
const char *<var>leaf</var>)</code></dt>

<dd><p>Returns a list of all the pathnames of existing data files to load. This 
includes the directories <code>$XDG_DATA_HOME</code> 
(defaulting to <samp>$HOME/.local/share</samp>) and
<code>$XDG_DATA_DIRS</code>
(defaulting to <samp>/usr/local/share:/usr/share</samp>). 

<p>If <var>leaf</var> is <code>NULL</code> then just the existing data
directories for <var>resource</var> are returned.  If
<var>resource</var>
is <code>NULL</code> then the existing data directories are returned.
</p>

<p>The return value may be NULL if no data directories or data files
could be found.  Otherwise <code>g_free()</code> each list item and
<code>g_list_free()</code> the whole list.</p>
</dd>

</dl>

<h4><a name="mime.h">mime.h</a></h4>
    <p>Interface to the Shared MIME database system.</p>

<dl>
      <dt><code>typedef struct mime_type MIMEType;</code></dt>

      <dd><p>This type represents a MIME type.  It has a number of
	members, two of which are public but read-only:</p> 
<ul>
<li><code>const char *media;</code>
<li><code>const char *subtype;</code>
</ul>
<p>These are the two parts of the MIME type media/subtype (e.g. 
<samp>text/plain</samp>).</p>
</dd>

<dt><code>extern MIMEType *text_plain;</code></dt>
<dd><p>MIME type representing <samp>text/plain</samp> files.  This is
the default for a file under *nix.</p>
<p><strong>This is not valid until <code>mime_init()</code>
has been called.</strong></p>
</dd>

<dt><code>extern MIMEType *application_executable;</code></dt>
<dd><p>MIME type representing <samp>application/x-executable</samp>
files.  
This represents an executable file.</p>
<p><strong>This is not valid until <code>mime_init()</code>
has been called.</strong></p>
</dd>

<dt><code>extern MIMEType *application_octet_stream;</code></dt>
<dd><p>MIME type representing <samp>application/octet-stream</samp>
files.  
This represents a non-text binary file.</p>
<p><strong>This is not valid until <code>mime_init()</code>
has been called.</strong></p>
</dd>

<dt><code>extern MIMEType *inode_directory;</code></dt>
<dd><p>MIME type representing <samp>inode/directory</samp>
files.  
This represents a directory.</p>
<p><strong>This is not valid until <code>mime_init()</code>
has been called.</strong></p>
</dd>

<dt><code>extern MIMEType *inode_mountpoint;</code></dt>
<dd><p>MIME type representing <samp>inode/mountpoint</samp>
files.  
This represents a directory on which a file system is mounted,
or may be mounted according to /etc/fstab. 
ROX-CLib does not yet recognize such objects.</p>
<p><strong>This is not valid until <code>mime_init()</code>
has been called.</strong></p>
</dd>

<dt><code>extern MIMEType *inode_pipe;</code></dt>
<dd><p>MIME type representing <samp>inode/fifo</samp>
files.  
This represents a pipe or FIFO object.</p>
<p><strong>This is not valid until <code>mime_init()</code>
has been called.</strong></p>
</dd>

<dt><code>extern MIMEType *inode_socket;</code></dt>
<dd><p>MIME type representing <samp>inode/socket</samp>
files.  
This represents a socket object.</p>
<p><strong>This is not valid until <code>mime_init()</code>
has been called.</strong></p>
</dd>

<dt><code>extern MIMEType *inode_block;</code></dt>
<dd><p>MIME type representing <samp>inode/blockdevice</samp>
files.  
This represents a block device object.</p>
<p><strong>This is not valid until <code>mime_init()</code>
has been called.</strong></p>
</dd>

<dt><code>extern MIMEType *inode_char;</code></dt>
<dd><p>MIME type representing <samp>inode/char</samp>
files.  
This represents a character device object.</p>
<p><strong>This is not valid until <code>mime_init()</code>
has been called.</strong></p>
</dd>

<dt><code>extern MIMEType *inode_door;</code></dt>
<dd><p>MIME type representing <samp>inode/door</samp>
files.  
This represents a door object (Solaris only).</p>
<p><strong>This is not valid until <code>mime_init()</code>
has been called.</strong></p>
</dd>

<dt><code>extern MIMEType *inode_unknwon;</code></dt>
<dd><p>MIME type representing <samp>inode/unknown</samp>
files.  
This represents an object which could not be identified
(probably missing).</p>
<p><strong>This is not valid until <code>mime_init()</code>
has been called.</strong></p>
</dd>

<dt><code>extern void mime_init(void)</code></dt>
<dd><p>Initializes the MIME system, defines the default types,
and loads the lookup database.
</p></dd>

<dt><code>extern MIMEType *mime_lookup(const char *path)</code></dt>
<dd><p>Returns the MIME type of the given file.  If the file exists
								    then
it is first checked for being a non-regular file.  If it is regular
and by content lookups are enabled the contents of the file is
								    checked.
If none of the above identifies the file then the file is identified
by its name.</p>
<p>In future a check may be made using extended attributes for
a user-defined MIME type.  This check will be made on regular files
before contents are checked.</p>
<p>The object returned is maintained by the MIME system and should
not be freed or modified.
</p></dd>

<dt><code>extern MIMEType *mime_lookup_by_name(const char *name)</code></dt>
<dd><p>Returns the MIME type object for the named type.
							    <var>name</var>
should be in the form <samp>media/subtype</samp>.</p>
<p>The object returned is maintained by the MIME system and should
not be freed or modified.
</p></dd>

<dt><code>extern char *mime_type_name(const MIMEType *type)</code></dt>
<dd><p>Returns the name of the MIME type in the form 
<samp>text/plain</samp>.  The returned string must be passed to
<code>g_free()</code> when done.
</p></dd>

<dt><code>extern const char *mime_type_comment(MIMEType *type)</code></dt>
<dd><p>Returns the comment field of the MIME type.  This is the 
human readable name of the type, such as <samp>C headers</samp> for
<samp>text/x-chdr</samp>.  Unlike <code>mime_type_lookup()</code>
this call reads one or more files, including 
<code>/uri/0install/zero-install.sourceforge.net/share</code>
and may take some time to complete.</p>
<p>The string returned is maintained by the MIME system and should
not be freed or modified.
</p></dd>

<dt><code>extern void mime_set_ignore_exec_bit(int ignore)</code></dt>
<dd><p>If <var>ignore</var> is non-zero then
<code>mime_type_lookup()</code> will check the name of executable
files for determining type and only return 
<code>application/x-executable</code> if that fails.  
Otherwise <code>application/x-executable</code> is always returned
for files with an executable bit set.
</p></dd>

<dt><code>extern int mime_get_ignore_exec_bit(void)</code></dt>
<dd><p>Returns the ignore executable bit flag.
</p></dd>

<dt><code>extern void mime_set_by_content(int content)</code></dt>
<dd><p>If <var>content</var> is zero then
<code>mime_type_lookup()</code> will not check the contents
of the file to determine the type.  This is the default.</p>
<p><em>Currently ignored as by-content lookups are not enabled.</em>
</p></dd>

<dt><code>extern int mime_get_by_content(void)</code></dt>
<dd><p>Returns the by content flag.
</p></dd>

</dl>

<h4><a name="appinfo.h">appinfo.h</a></h4>
    <p>An object representing a parsed AppInfo.xml file.</p>

<dl>
      <dt><code>typedef struct _ROXAppInfo ROXAppInfo;</code></dt>

      <dd><p>This type represents an AppInfo.xml.  It is derived from
GObject.</p></dd>
</dd>

<dt><code>GObject *rox_appinfo_new(void)</code></dt>
<dd><p>This parses the current app's AppInfo.xml file and returns a 
pointer to a
<code>ROXAppInfo</code> object.  If $APP_DIR is unset,
							  $APP_DIR/AppInfo.xml is missing or not valid XML then <code>NULL</code> is returned.</p>
<p>You should call 
<code>g_object_unref()</code> to free this object when done.</p></dd>

<dt><code>GObject *rox_appinfo_new_from_path(const gchar *<var>path</var>)</code></dt>
<dd><p>This parses the named AppInfo.xml file and returns a 
pointer to a
<code>ROXAppInfo</code> object.  If <var>path</var> is missing or not valid XML then <code>NULL</code> is returned.</p>
<p>You should call 
<code>g_object_unref()</code> to free this object when done.</p></dd>

<dt><code>void rox_appinfo_set_language(ROXAppInfo *<var>ai</var>,
    const gchar *<var>lang</var>)</code></dt>
<dd><p>Set the language used when parsing the AppInfo data.  If
<var>lang</var> is <code>NULL</code> then the data returned will be
that with no language set, otherwise the appropriate elements for the
set language will be returned, falling back to the no language
elements if the specific language is not found.</p></dd>

<dt><code>const char *rox_appinfo_get_language(ROXAppInfo *<var>ai</var>)</code></dt>
<dd><p>Return the language code used when parsing the AppInfo data.
This may be <code>NULL</code> for no language set.</p></dd>

<dt><code>const char *rox_appinfo_get_summary(ROXAppInfo *<var>ai</var>)</code></dt>
<dd><p>Return the contents of the Summary element.</p></dd>

<dt><code>char *rox_appinfo_get_about(ROXAppInfo *<var>ai</var>,
const gchar *<var>element</var>)</code></dt>
<dd><p>Return the contents of the named element in the About element.
Pass the return value to <code>g_free()</code> when done.</p></dd>

<dt><code>char *rox_appinfo_get_label(ROXAppInfo *<var>ai</var>,
const gchar *<var>element</var>)</code></dt>
<dd><p>Return the label for the named element in the About element in
the current language.  If this is not set or is empty then a copy of 
<var>element</var> is returned.
Pass the return value to <code>g_free()</code> when done.</p></dd>

<dt><code>const xmlNodePtr rox_appinfo_get_element(ROXAppInfo *<var>ai</var>,
const gchar *<var>element</var>)</code></dt>
<dd><p>Return the <code>xmlNode</code> object for the named element.  
Only child elements of the root AppInfo element are searched, no
recursive search is performed.  <code>NULL</code> is returned if no
element was found, otherwise just the first matching entry is
returned.  Language is not checked.</p>
<p><code>xmlNodePtr</code> is part of libxml.</p></dd>

<dt><code>GList *rox_appinfo_get_mime_type_list(ROXAppInfo *<var>ai</var>,
const gchar *<var>element</var>)</code></dt>
<dd><p>Returns a list of <a href="#mime.h"><code>MIMEType *</code></a>
objects.  The mime types are listed in &lt;MimeType&gt; elements in
the top level <var>element</var> element (found by
<code>rox_appinfo_get_element()</code>).  See the AppInfo.xml file for
VideoThumbnail for an example.</p></dd>

<dt><code>void rox_appinfo_free_mime_type_list(
GList *<var>list</var>)</code></dt>
<dd><p>Free a list of <a href="#mime.h"><code>MIMEType *</code></a>
objects, as returned by <code>rox_appinfo_get_mime_type_list()</code>.</p></dd>

<dt><code>GList *rox_appinfo_get_can_run_list(ROXAppInfo *<var>ai</var>)</code></dt>
<dd><p>Returns a list of <a href="#mime.h"><code>MIMEType *</code></a>
objects declared in the &lt;CanRun&gt; element.  This is equivalent to
<code>rox_appinfo_get_mime_type_list(ai, "CanRun").
</dd></p>

<dt><code>GList *rox_appinfo_get_can_thumbnail_list(ROXAppInfo *<var>ai</var>)</code></dt>
<dd><p>Returns a list of <a href="#mime.h"><code>MIMEType *</code></a>
objects declared in the &lt;CanThumbnail&gt; element.  This is equivalent to
<code>rox_appinfo_get_mime_type_list(ai, "CanThumbnail").
See the AppInfo.xml file for
VideoThumbnail for an example.</p></dd>

</dl>

<h4><a name="mime_handler.h">mime_handler.h</a></h4>
    <p>Install handlers for MIME types.</p>

<dl>
      <dt><code>void rox_mime_install_from_appinfo(void)</code></dt>

      <dd><p>This offers the user a chance to install the current application
as the handler for those types given in the application's
AppInfo.xml file.  Types given in the &lt;CanRun&gt; element are
offered as run actions and SendTo, those in the  &lt;CanThumbnail&gt;
element are offered as the thumbnail handler.</p></dd>
</dd>
</dl>

<h4><a name="uri.h">uri.h</a></h4>
    <p>Utilities for uri handling and launching.</p>

<dl>

      <dt><code>gchar *rox_unescape_uri(const gchar *<var>uri</var>)</code>
<dd><p>Converts all %xx escape sequences in <var>uri</var> back into 
characters.</p>

      <dt><code>gchar *rox_escape_uri_path(const gchar *<var>path</var>)</code>
<dd><p>Converts all problematic characters in <var>path</var>
into %xx escape sequences.</p>

      <dt><code>gchar *rox_encode_path_as_uri(const gchar *<var>uri</var>)</code>
<dd><p>Converts all problematic characters in <var>path</var>
into %xx escape sequences and adds a 
<code>file://<var>hostname</var></code> prefix.  <var>hostname</var>
  is as returned from <code>rox_hostname</code></p>

<dt><code>int <a name="rox_uri_launch">rox_uri_launch</a>(const char *<var>uri</var>)</code>
<dd><p>Attempt to launch <var>uri</var> by passing to the handler for
	  the mime type text/x-uri.  If no handler is defined attempt
to open it in mozilla or netscape.  The return value is the exit
status of the command used to launch.
</p>

      <dt><code>const char *<a name="rox_hostname">rox_hostname(const gchar *<var>uri</var>)</code>
<dd><p>Returns the hostname which will be used in drag and drop operations.</p>

</dl>

    <hr>
    <address><a href="mailto:stephen@kerofin.demon.co.uk">Stephen Watson</a></address>
<!-- Created: Tue Nov 26 10:46:50 GMT 2002 -->
<!-- hhmts start -->
Last modified: Sat Oct 23 12:48:28 BST 2004
<!-- hhmts end -->
  </body>
</html>

