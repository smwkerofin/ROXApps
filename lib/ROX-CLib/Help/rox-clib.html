<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
  <head>
    <!-- $Id: rox-clib.html,v 1.3 2003/10/22 17:24:35 stephen Exp $ -->
    <title>ROX-CLib</title>
  </head>

  <body>
    <h1>ROX-CLib</h1>

    <p>A library for ROX applications written in C.

    <h2>For Users</h2>

    <h3>Installation</h3>
    <p>Copy to a suitable place, such as <samp>~/lib</samp>, 
      and make sure it is on 
      your <samp>$LIBDIRPATH</samp>.

    <p>Compile using <samp>ROX-CLib/AppRun --compile</samp>

    <h2>For Programmers</h2>

    <h3>Compiling and linking against the library</h3>

<p>Add the output of
    <pre>   rox_run ROX-CLib --cflags</pre>
to your compile line, e.g.
    <pre>   gcc `rox_run ROX-CLib --cflags` -c main.c </pre>

<p>Add the output of
<pre>   rox_run ROX-CLib --cflags
   rox_run ROX-CLib --libs</pre>
to your link line, e.g.
    <pre>   gcc `rox_run ROX-CLib --cflags` -o main main.o `rox_run ROX-CLib --libs`</pre>

<p>If you are using autoconf and building a ROX program then:
<p>In src/configure.in add:
<pre>  if test -z "$ROX_RUN"; then
    AC_CHECK_PROG(ROX_RUN, rox_run, rox_run, "$APP_DIR/rox_run")
  fi
  AC_SUBST(ROX_RUN)</pre>

<p>In src/Makefile.in add:
<pre>  ROX_CLIB = @ROX_RUN@ ROX-CLib</pre>
    and to CFLAGS add: <samp>`${ROX_CLIB} --cflags`</samp>
    and to LDFLAGS add: <samp>`${ROX_CLIB} --libs`</samp>

<p>In AppRun and AppletRun ensure you have:
<pre>
   APP_DIR=`dirname $0`
   APP_DIR=`cd $APP_DIR;pwd`; export APP_DIR
   if [ -z "$LD_LIBRARY_PATH" ]; then
       LD_LIBRARY_PATH=`$APP_DIR/rox_run ROX-CLib --runtime`
   else
       LD_LIBRARY_PATH=`$APP_DIR/rox_run ROX-CLib --runtime`:$LD_LIBRARY_PATH
   fi
   export LD_LIBRARY_PATH
</pre>

    <p>Finally put <samp>rox_run</samp> in your application directory. 

    <h3>Library reference</h3>

    <p>Organized by header file.

    <ul>
      <li><a href="#rox.h">rox.h</a></li>
      <li><a href="#choices.h">choices.h</a></li>
      <li><a href="#error.h">error.h</a></li>
      <li><a href="#gtksavebox.h">gtksavebox.h</a></li>
      <li><a href="#infowin.h">infowin.h</a></li>
      <li><a href="#rox_debug.h">rox_debug.h</a></li>
      <li><a href="#rox_dnd.h">rox_dnd.h</a></li>
      <li><a href="#rox_path.h">rox_path.h</a></li>
      <li><a href="#rox_resources.h">rox_resources.h</a></li>
      <li><a href="#rox_soap.h">rox_soap.h</a></li>
      <li><a href="#rox_filer_action.h">rox_filer_action.h</a></li>
      <li><a href="#applet.h">applet.h</a></li>
      <li><a href="#rox_soap_server.h">rox_soap_server.h</a></li>
    </ul>

    <h4><a name="rox.h">rox.h</a></h4>

    <p>Top level include.  It includes:
    <ul>
      <li> <a href="#choices.h"> choices.h</a></li>
      <li><a href="#error.h">  error.h</a></li>
      <li> <a href="#rox_debug.h"> rox_debug.h</a></li>
      <li> <a href="#rox_resources.h"> rox_resources.h</a></li>
      <li> <a href="#infowin.h"> infowin.h</a></li>
    </ul>

    <p>Six functions are declared:

    <dl>
      <dt>
	<code>void rox_init(const char *program, int *argc, char ***argv)</code>
      <dd><p>

	  This handles the initialization of the library.  It calls:
	</p>
        <ul>
          <li><code>gtk_init(argc, argv)</code>
          <li><code>rox_debug_init(program)</code>
          <li><code>choices_init()</code>
          <li><code>options_init(program)</code> (if it detects an
					      $APP_DIR/Options.xml file)
          <li><code>rox_dnd_init()</code>
        </ul>

      <dt>
	<code><const gchar *rox_get_program_name(void);/code>
      <dd><p>

	  Returns the program name, as passed to rox_init().  If
					      rox_init() was not
					      called then it returns NULL.
	</p>

      <dt>
	<code>int rox_clib_version_number(void)</code>
      <dd><p>

	  Returns the version number of the library, so that 1.2.3 is encoded as 10203.
	</p>

      <dt>
	<code>const char *rox_clib_version_string(void)</code>

      <dd><p>
	  Returns a string of the version number of the library, in the form
	  "x.y.z (nth month year)".
	</p>

      <dt>
	<code>int rox_clib_gtk_version_number(void)</code>
      <dd><p>

	  Returns the version number of the GTK+ library ROX-CLib is
	  linked against, so that 1.2.3 is encoded as 10203.
	</p>

      <dt>
	<code>const char *rox_clib_gtk+version_string(void)</code>

      <dd><p>
	  Returns a string of the version number of the GTK+ library
	  ROX-CLib is 
	  linked against.
	</p>
    </dl>

<h4><a name="choices.h">choices.h</a></h4>
    <p>Interface to the choices system and $CHOICESPATH.  Originally by 
      <a href="mailto:tal197@users.sourceforge.net">Thomas Leonard</a> and
      taken from the ROX-Filer source.

    <dl>
      <dt>
	<code>void choices_init(void)</code>

      <dd><p>Must be called before the other choices_* calls.</p>

      <dt>
	<code>GPtrArray *choices_list_dirs(const char *<var>dir</var>)</code>

<dd><p>Returns an array of the directories in CHOICESPATH which contain
	  a subdirectory called '<var>dir</var>'.  The result should be freed by passing it
	  to <code>choices_free_list()</code></p>

      <dt>
	<code>void choices_free_list(GPtrArray *<var>list</var>)</code>

      <dd><p>Frees the list returned by <code>choices_list_dirs()</code></p>

      <dt>
	<code>gchar *choices_find_path_load(const char *<var>leaf</var>, const char *<var>dir</var>)</code>

<dd><p>Get the pathname of a choices file to load. Eg:

	<code>choices_find_path_load("menus", "ROX-Filer")</code>
	-> <samp>"/usr/local/share/Choices/ROX-Filer/menus"</samp>.

<p>The return values may be NULL - use built-in defaults - otherwise
	  <code>g_free()</code> the result.</p>

      <dt>
	<code>gchar *choices_find_path_save(const char *<var>leaf</var>, const char *<var>dir</var>, 
	  gboolean <var>create</var>)</code>

<dd><p>Returns the pathname of a file to save to, or NULL if saving is
	  disabled. If <var>'create'</var> is TRUE then intermediate directories will
be created (set this to FALSE if you just want to find out where
a saved file would go without actually altering the filesystem).

	<p><code>g_free()</code> the result.</p>

</dl>


    <h4><a name="error.h">error.h</a></h4>

    <p>Reporting errors.

    <dl>
      <dt><code>void rox_error(const char *<var>fmt</var>, ...)</code>

    <dd><p>Generates a string according to a printf style formatting
      string and supplied 
      args, then displays the string in a dialog window with the title
      "Error!" and 
      an OK button.
    </dl>

    <h4><a name="gtksavebox.h">gtksavebox.h</a></h4>

<p>Simple RISC OS style save box.

<p>GtkSaveBox is a GTK+ widget, derived from GtkWindow.  Originally by 
      <a href="mailto:tal197@users.sourceforge.net">Thomas Leonard</a> and
      taken from the ROX-Filer source.

    <dl>
      <dt>Functions
      <dd>
	<dl>
	  <dt><code>GtkWidget* gtk_savebox_new(void)</code>
	  <dd><p>Creates the GtkSaveBox widget.</p>

	  <dt><code>void gtk_savebox_set_icon(GtkSavebox *<var>savebox</var>,
	      GdkPixmap *<var>pixmap</var>, 
	      GdkPixmap *<var>mask</var>)</code>
	  <dd><p>Sets the icon that may be dragged about.</p>

	  <dt><code>void gtk_savebox_set_pathname(GtkSavebox
	      *<var>savebox</var>, gchar *<var>pathname</var>)</code> 
	  <dd><p>Sets the pathname in the entry box.</p>
	</dl>

      <dt>Types
      <dd>
	<dl>
	  <dt><code>enum {
  GTK_XDS_SAVED,
  GTK_XDS_SAVE_ERROR,
  GTK_XDS_NO_HANDLER,
}</code>
	  <dd><p>Used by the <code>save_to_file</code> signal:
	    <table>
 <tr><td>GTK_XDS_SAVED</td> <td>Done the save - no problem</td></tr>
 <tr><td>GTK_XDS_SAVE_ERROR</td><td> Error during save - reported</td> </tr>
 <tr><td>GTK_XDS_NO_HANDLER</td> <td>Used internally (sanity checking)</td> </tr>
	      
	    </table>

	</dl>

      <dt>Signals
      <dd>
	<dl>
	  <dt><code>gint save_to_file(GtkSavebox *<var>savebox</var>,
	      const gchar *<var>pathname</var>)</code> 
	  <dd><p>Save the data to disk using this pathname. Return 
	      <code>GTK_XDS_SAVED</code>
	      on success, or <code>GTK_XDS_SAVE_ERROR</code> on
	      failure (and report the error 
	to the user somehow). DO NOT mark the data unmodified or change
	the pathname for the file - this might be a scrap file transfer.
	    </p>

	  <dt><code>void saved_to_uri(GtkSavebox *<var>savebox</var>, 
	      const gchar
	      *<var>uri</var>)</code>

	  <dD><p> The data is saved. If '<var>uri</var>' is non-NULL, mark the file as unmodified
 and update the pathname/uri for the file to the one given.</p>

	</dl>
    </dl>

    <h4><a name="infowin.h">infowin.h</a></h4>

    <p>RISC OS style information window.

    <p>InfoWin is a GTK+ widget, derived from GtkDialog.
    <dl>
      <dt>Functions
      <dd>
	<dl>
	  <dt><code>GtkWidget* info_win_new(const gchar *<var>program</var>, 
	      const gchar *<var>purpose</var>,
	      const gchar *<var>version</var>, const gchar *<var>author</var>,
	      const gchar *<var>website</var>)</code>

	    <dd><p>Create a new InfoWin object.  The data in the
	      window is taken from the function arguments.</p>

	  <dt><code>GtkWidget* info_win_new_from_appinfo(const gchar *<var>program</var>)</code>

	    <dd><p>Create a new InfoWin object.  The data in the
	      window is taken from the file $APP_DIR/AppInfo.xml, if
							    it exists.</p>

	  <dt><code>void info_win_add_browser_command(InfoWin *<var>iw</var>, 
	      const gchar *<var>cmd</var>)</code>

	  <dd><p>Adds a command which will visit a named web site.
	      The command will be called with a single argument, then
	      URL passed in <code>info_new_win()</code>. 
	    </p>

	</dl>

      <dt>Signals
      <dd><p>None.</p>
    </dl>

    <h4><a name="rox_debug.h">rox_debug.h</a></h4>


    <p>Utilities for generating debug output.  Unless the pre-processor symbol 
      <code>DEBUG</code> is defined and non-zero before rox_debug.h is
      included then nothing  is declared.

    <dl>
      <dt>
	<code>void rox_debug_init(const char *<var>progname</var>)</code>

      <dd><p>
	  Initialises the debug system.  <var>progname</var> is the
	  name of the program which will  
	  prefix the output.  Should be called at start, if not (or
	  <var>progname</var>==NULL)  
	  then <var>progname</var> is assumed to be "ROX".</p>

      <dt>
	<code>void rox_debug_printf(int <var>level</var>, 
	  const char *<var>format</var>, ...)</code>

	<dd><p>Sends a debug message, using glib's <code>g_logv</code>.  <var>level</var> is the level of severity
and should be in the range 0-5, with 0 most severe.  The user controls the
	amount of output by setting the environment <var>PROGNAME_DEBUG_LEVEL</var> to the
maximum severity to display.<p>

      <dt>
	<code>#define dprintf rox_debug_printf</code>

      <dd><p>Aliases <code>dprintf</code> as <code>rox_debug_printf</code></p>
    </dl>

    <h4><a name="rox_dnd.h">rox_dnd.h</a></h4>


<p>Utilities to simplify the handling of drag and drop for the client.
Based on the ROX-Filer code written by
<a href="mailto:tal197@users.sourceforge.net">Thomas Leonard</a>

<dl>
<dt><code>typedef gboolean (*rox_dnd_handle_uris)(GtkWidget *widget,
					GSList *uris,
					gpointer data,
					gpointer udata)</code>

<dd><p>Type of function called when a widget registered with rox_dnd has a list
of URIs dropped on it. It should return TRUE if handled successfully, 
FALSE otherwise.</p>

<dt><code>typedef gboolean (*rox_dnd_handle_xds)(GtkWidget *widget,
					const gchar *path,
					gpointer data,
					gpointer udata)</code>

<dd><p>Type of function called when a widget registered with rox_dnd has a 
direct save on it. It should return TRUE if handled successfully, 
FALSE otherwise.</p>

<dt><code>void rox_dnd_init(void)</code>

<dd><p>Called to initialise rox_dnd, before any other call.</p>

      <dt><code>void rox_dnd_register_full(GtkWidget *<var>widget</var>,
	  guint <var>flags</var>,
	  rox_dnd_handle_uris <var>uris</var>,
	  rox_dnd_handle_xds <var>xds</var>,
	  gpointer <var>udata</var>)</code>

<dd><p>Registers a widget with rox_dnd to handle any drops on it.  There are no
	  flags defined yet, so <var>flags</var> must be set to zero.  <var>uris</var> handles URI list drops,
	  <var>xds</var> handles the XDirectSave protocol.  <var>udata</var>
is passed to the handler routine.</p>

      <dt><code>GSList *rox_dnd_filter_local(GSList *<var>uris</var>)</code>

<dd><p>Scans list of URIs and picks out only those that refer to local files.
Free result with rox_dnd_local_free().</p>

<dt><code>void rox_dnd_local_free(GSList *paths)</code>
<dd><p>Frees the data returned by rox_dnd_filter_local().</p>
</dl>

    <h4><a name="rox_path.h">rox_path.h</a></h4>

<p>Utilities for handling the URIs used in the drag & drop protocol.  All 
      returned strings should be passed to <code>g_free()</code> when done.

<dl>
      <dt><code>gchar *rox_path_get_local(const gchar *<var>uri</var>)</code>

<dd><p>Returns the local path of the URI if it refers to a local file: path, otherwise
it returns NULL.</p>

      <dt><code>gchar *rox_path_get_server(const gchar *<var>uri</var>)</code>

<dd><p>Returns the host part of the URI if it is a file: URI, otherwise
it returns NULL.</p>

      <dt><code>gchar *rox_path_get_path(const gchar *<var>uri</var>)</code>

<dd><p>Returns the path part of a file: URI regardless of whether it is the local
host or not.</p>

      <dt><code>gchar *unescape_uri(const gchar *<var>uri</var>)</code>
<dd><p>Converts all %xx escape sequences in <var>uri</var> back into 
characters.</p>

      <dt><code>gchar *escape_uri_path(const gchar *<var>path</var>)</code>
<dd><p>Converts all problematic characters in <var>path</var>
into %xx escape sequences.</p>

      <dt><code>gchar *encode_path_as_uri(const gchar *<var>uri</var>)</code>
<dd><p>Converts all problematic characters in <var>path</var>
into %xx escape sequences and adds a 
<code>file://<var>hostname</var></code> prefix.</p>

</dl>

    <h4><a name="rox_resources.h">rox_resources.h</a></h4>


<p>Utility functions for finding resource files, which may be locale specific.

<dl>
      <dt><code>gchar *rox_resources_find(const gchar *<var>app_name</var>,
	  const gchar *<var>leaf</var>,
	  const gchar *<var>lang</var>)</code>

      <dd><p>Search <code>$CHOICESPATH</code>, then
	  <code>$APP_DIR</code> for a directory called
	  <samp>Resources</samp> 
	  which contains the file <samp>leaf</samp>, whether in a
	  sub-directory <samp>lang</samp> or 
	  directly.  Returns the full path if found (pass to
	  <code>g_free</code> when done) 
	  or <code>NULL</code> if not.  lang may be
	  <code>ROX_RESOURCES_NO_LANG</code> to not search 
	  for sub-directories, or
	  <code>ROX_RESOURCES_DEFAULT_LANG</code> for the
	  sub-directory 
	  appropriate for the selected language.

	<p>If the language is set to <samp>en_GB.ISO8859-1</samp> then
	  the sub-directories tried are:
<ul>
	  <li><var>{Choices}</var>/<var>app_name</var>/en_GB.ISO8859-1/
	  <li><var>{Choices}</var>/<var>app_name</var>/en.ISO8859-1/
	  <li><var>{Choices}</var>/<var>app_name</var>/en_GB/
	  <li><var>{Choices}</var>/<var>app_name</var>/en/
	  <li><var>{Choices}</var>/<var>app_name</var>/
</ul>
in that order.</p>
</dl>

    <h4><a name="rox_soap.h">rox_soap.h</a></h4>

<p>Communicating with the filer via SOAP. 
Based on the ROX-Filer code written by
<a href="mailto:tal197@users.sourceforge.net">Thomas Leonard</a>

<dl>
      <dt><code>typedef struct rox_soap_filer ROXSOAP;</code>

      <dd><p>This is an opaque type representing the connection to an
	  instance of the filer.</p> 

      <dt><code>typedef void (*rox_soap_callback)(ROXSOAP *filer, 
	  gboolean status, 
	  xmlDocPtr reply, 
	  gpointer udata)</code>

      <dd><p>Defines the function called when the SOAP call completes.
	  If <var>status</var> is <code>FALSE</code>  
	  then the call failed and reply is <code>NULL</code>.  If
	  <var>status</var> is not <code>FALSE</code> then the call  
	  succeeded and <var>reply</var> contains the result (may
	  still be <code>NULL</code>). </p>

      <dt><code>void rox_soap_init(void);</code>
=09
      <dd><p>Initializes the data.</p>

      <dt><code>void rox_soap_define_program(const char
	  *<var>name</var>, 
	  const char *<var>atom_fmt</var>,
	  const char *<var>command</var>);</code>

      <dd><p>Define how to connect to the named program.
	  <table>
	    <tr><td><var>name</var></td>
	      <td>name of program as passed to rox_soap_connect</td></tr>
	    <tr><td><var>atom_fmt</var></td>
	      <td>format of atom name to use to connect, %e is effective UID,
		%h is FQDN of display</td></tr>
	    <tr><td><var>command</var></td>
	      <td>command that may be fed the SOAP document on stdin if
		connecting via the atom fails, may be NULL</td></tr>
	  </table>
	  
	<p>An entry for ROX-Filer is pre-defined. 
	  (<samp>"ROX-Filer"</samp>, 
	  <samp>"_ROX_FILER_%e_%h"</samp>,
	  <samp>"rox -R"</samp>).</p>

      <dt><code>char *rox_soap_atom_name_for_program(const char *
	  <var>name</var>);</code>

      <dd><p>Returns the name of the atom which will be used to locate the given program.
	  It uses the format given in the <code>rox_soap_define_program()</code> call, with the
	  defined substitutions.  Pass to <code>g_free()</code> when done.</p>

      <dt><code>gboolean rox_soap_ping(const char *<var>prog</var>);</code>

      <dd><p>Returns <code>TRUE</code> if the named program is contactable via SOAP.</p>

      <dt><code>ROXSOAP *rox_soap_connect(const char *<var>prog_name</var>);</code>

<dd><p>Initialise the connection to the named program.</p>

<dt><code>ROXSOAP *rox_soap_connect_to_filer(void);</code>

<dd><p>Initialise the connection to the filer.</p>

      <dt><code>gboolean rox_soap_send(ROXSOAP *<var>program</var>, 
	  xmlDocPtr <var>doc</var>, gboolean <var>run_prog</var>,
	  rox_soap_callback <var>callback</var>, 
	  gpointer <var>udata</var>);</code>

      <dd><p>Send the XML document to program using SOAP.  If
	  <var>run_prog</var> is <code>TRUE</code> 
	  and there is no program to talk to, use
	  <code>rox_soap_send_via_pipe()</code>. 
	  Returns <code>TRUE</code> if comms succeeded, when complete
	  <var>callback</var> is called with 
	  the status and reply.</p> 

      <dt><code>gboolean rox_soap_send_via_pipe(ROXSOAP *<var>filer</var>, 
	  xmlDocPtr <var>doc</var>, 
	  rox_soap_callback <var>callback</var>, 
	  gpointer <var>udata</var>);</code>


      <dd><p>Send the XML document to the program, using the command defined by
	  <code>rox_soap_define_program()</code>.  When complete
	  <var>callback</var> is called with the 
	  status and reply.</p>

      <dt><code>void rox_soap_set_timeout(ROXSOAP *<var>filer</var>, 
	  guint <var>ms</var>);</code>

      <dd><p>Set the timeout when contacting ROX-Filer (in ms,
	  defaults to 10000).  If 
	  filer is <code>NULL</code> it sets the timeout for all new
	  connections.</p> 

      <dt><code>xmlDocPtr rox_soap_build_xml(const char *<var>action</var>, 
	  const char *<var>ns_url</var>,
	  xmlNodePtr *<var>act</var>);</code>

      <dd><p>Build part of XML document to send.  The action to
	  perform is in name 
	  space <var>ns_url</var>.  Add arguments to the node
	  <var>act</var>, then call <code>rox_soap_send()</code> 
	  with the return value.</p>

      <dt><code>const char *rox_soap_get_last_error(void);</code>

      <dd><p>Returns the text of the last error raised.  This may be
	  <code>"No error"</code> if no error 
	  has occured, or <code>rox_soap_clear_error()</code> has been
	  called.</p> 

      <dt><code>void rox_soap_clear_error(void);</code>

      <dd><p>Clears the error text.</p>

      <dt><code>void rox_soap_close(ROXSOAP *<var>filer</var>);</code>

      <dd><p>Close connection.</p>
    </dl>

    <h4><a name="rox_filer_action.h">rox_filer_action.h</a></h4>

<p>These functions drive ROX-Filer via the rox_soap.h interface above.

<dl>
<dt><code>
typedef enum panel_side {
  ROXPS_TOP,ROXPS_BOTTOM,ROXPS_LEFT,ROXPS_RIGHT
} ROXPanelSide;</code>

<dd><p>The four possible places for a panel, used in rox_filer_panel().</p>

<dt><code>#define ROX_FILER_DEFAULT (-1)  </code>

<dd><p>This value means "use value user has selected in options".</p>

<dt><code>char *rox_filer_version(void);</code>

      <dd><p>Return the version string for the current filer.  Return
      value should be passed to g_free when done.</p>

      <dt><code>void rox_filer_open_dir(const char
      *<var>filename</var>);</code>

<dd><p>Open a viewer for the given directory.</p>

      <dt><code>void rox_filer_close_dir(const char *<var>filename</var>);</code>

<dd><p>Close all viewers for the given directory and any subdirectories.</p>

      <dt><code>void rox_filer_examine(const char *<var>filename</var>);</code>

<dd><p>Re-fresh the viewer for the given directory.</p>

      <dt><code>void rox_filer_panel(const char *<var>name</var>, ROXPanelSide <var>side</var>);</code>

      <dd><p>Open a panel with the given name on the specfied side.
      If <var>name</var> is "" then the panel on that side is closed
      instead.</p>

      <dt><code>void rox_filer_panel_add(ROXPanelSide <var>side</var>,
      const char *<var>path</var>, int <var>after</var>);</code>

      <dd><p>Add an object to the panel on the specfied side.  If
      <var>after</var> is <code>FALSE</code> then the object is placed
      on the left (top or bottom panels) or top (left or right
      panels), otherwise the other end.</p>

      <dt><code>void rox_filer_pinboard(const char *<var>name</var>);</code>

      <dd><p>Display pinboard name on the desktop background.
      <var>Name</var> can be a name in Choices (eg, `MyPinboard') or a
      full pathname.</p>

      <dt><code>void rox_filer_pinboard_add(const char
      *<var>path</var>, int <var>x</var>, int <var>y</var>);</code>

<dd><p>Add an object to the pinboard at the specfied co-ordinates. </p> 

      <dt><code>void rox_filer_run(const char *<var>filename</var>);</code>

      <dd><p>Run <var>filename</var> as if it was clicked on in the filer.</p>

      <dt><code>void rox_filer_show(const char *<var>directory</var>, const char *<var>leafname</var>);</code>

      <dd><p>Open <var>directory</var> and flash the file <var>leafname</var> inside it.</p>

      <dt><code>void rox_filer_copy(const char *<var>from</var>, 
	  const char *<var>to</var>,
	  const char *<var>leafname</var>, int <var>quiet</var>);</code>

      <dd><p>Copy the object <var>from</var> into the directory
      <var>to</var>.  If leafname is not <code>NULL</code> then use it
      as the new name of the file.  If <var>quiet</var> is
      <code>FALSE</code> then prompt the user before copying.</p>

      <dt><code>void rox_filer_move(const char *<var>from</var>, 
	  const char *<var>to</var>,
	  const char *<var>leafname</var>, int <var>quiet</var>);</code>

      <dd><p>Move the object <var>from</var> into the directory
      <var>to</var>.  If <var>leafname</var> is not <code>NULL</code>
      then use it as the new name of the file.  If <var>quiet</var> is
      <code>FALSE</code> then prompt the user before moving.</p>

      <dt><code>void rox_filer_link(const char *<var>from</var>, 
	  const char *<var>to</var>,
	  const char *<var>leafname</var>);</code>

      <dd><p>Symbolically link the object <var>from</var> into the
      directory <var>to</var>.  If <var>leafname</var> is not
      <code>NULL</code> then use it as the new name of the file.</p>

      <dt><code>void rox_filer_mount(const char *<var>mountpoint</var>,
	  int <var>quiet</var>, int <var>opendir</var>);</code>

      <dd><p>Attempt to mount on the directory <var>mountpoint</var>
      (which should be in <code>/etc/fstab</code> or similar).  If
      <var>quiet</var> is <code>FALSE</code> then prompt the user
      before mounting.  If <var>opendir</var> is not
      <code>FALSE</code> then open a viewer for the new directory if
      succesfully mounted.  The ability to mount is normally
      restricted.</p>

      <dt><code>char *rox_filer_file_type(const char *<var>file</var>);</code>

      <dd><p>Return a string describing the MIME type of the given
      <var>file</var> (which need not exist!).  Return value should be
      passed to <code>g_free</code> when done.  If <code>NULL</code>
      is returned then there was an error in communication.</p>

<dt><code>int rox_filer_have_error(void);</code>

<dd><p>Returns non-zero if an error message is available.</p>

<dt><code>const char *rox_filer_get_last_error(void);</code>

      <dd><p>Returns the text of the last error raised.  This may be
      <code>"No error"</code> if no error has occured, or
	  <code>rox_filer_clear_error()</code> has been called.</p>

<dt><code>void rox_filer_clear_error(void);</code>

<dd><p>Clears the error text.</p>
</dl>

    <h4><a name="applet.h">applet.h</a></h4>


<p>Utilities for developing ROX applets.

<dl>
<dt>
<code>typedef enum panel_location {
  PANEL_TOP, PANEL_BOTTOM, PANEL_LEFT, PANEL_RIGHT,
  PANEL_UNKNOWN
} PanelLocation;</code>

<dd><p>Defines the four possible locations for the panel containing the applet,
plus an error condition.</p>

<dt>
	<code>extern void applet_popup_menu(GtkWidget *<var>plug</var>, 
	  GtkWidget *<var>menu</var>, 
	  GdkEventButton *<var>evbut</var>);</code>

<p>Shows a pop-up menu in a suitable place for the applet.  It is
assumed that this will be called in a <code>button_press</code>
handler which is passed a <code>GdkEventButton *</code>.
<var>plug</var> is the GtkPlug object which is the applets window.</p>

</dl>

    <h4><a name="rox_soap_server.h">rox_soap_server.h</a></h4>

<p>Provides a ROX-Filer like SOAP server.
Based on the ROX-Filer code written by
<a href="mailto:tal197@users.sourceforge.net">Thomas Leonard</a>

<dl>
<dt><code>typedef struct rox_soap_server ROXSOAPServer;</code>

<dd><p>This is an opaque object representing the server.</p>

<dt><code>typedef xmlNodePtr (*rox_soap_server_action)(ROXSOAPServer *server,
				       const char *action_name,
				       GList *args, gpointer udata);</code>

<dd><p>This represents the type of the function called when a SOAP
method is executed.  Any reply should be returned as an XML node.
<var>args</var> is a list of the arguments passed as XML nodes, in the
order they were defined in <code>rox_soap_server_add_action()</code>
(required, then optional).  Optional arguments may be
<code>NULL</code>.</p>

<dt><code>void rox_soap_server_init(void);</code>

<dd><p>Initialise the server routines.</p>

      <dt><code>ROXSOAPServer *rox_soap_server_new(
	  const char *<var>program_name</var>,
	  const char *<var>ns_url</var>);</code>

      <dd><p>Create a new server object and advertise it via the root
      window.  <var>program_name</var> is the name of the program (see
      <code>rox_soap_define_program()</code>).  <var>ns_url</var> is
      the name space URL.</p>

      <dt><code>void rox_soap_server_add_action(
	  ROXSOAPServer *<var>server</var>,
	  const char *<var>action_name</var>,
	  const char *<var>args</var>,
	  const char *<var>optional_args</var>,
	  rox_soap_server_action <var>action</var>,
	  gpointer <var>udata</var>);</code>

      <dd><p>Define a new method (or action) supported by this server.
      <var>action_name</var> is the name of the action.
      <var>args</var> is a string of a comma seperated list of
      arguments, or <code>NULL</code> if there are no required
      arguments.  <var>optional_args</var> is a string of a comma
      seperated list of arguments, or <code>NULL</code> if there are
      no optional arguments.  <var>action</var> is the function to
      call when a correctly formatted SOAP message is received.</p>

      <dt><code>void rox_soap_server_delete(
	  ROXSOAPServer *<var>server</var>);</code>

<dd><p>Shutdown the server and release its memory.</p>
</dl>

<h4><a name="options.h">options.h</h4>

<p>Options system for configuring your program, similar to ROX-Filer's
      options.
Based on the ROX-Filer code written by
<a href="mailto:tal197@users.sourceforge.net">Thomas Leonard</a>

<dl>
      <dt><code>typedef struct _Option Option;</code>

<dd><p>Object used to store an option.  The following members are used to access the
values:
<dl>
	  <dt><code>gchar *value</code>		
<dd><p>Value of the option, as a string</p>
	  <dt><code>long int_value</code>	
<dd><p>Value of the option, as a number</p>
	  <dt><code>gboolean has_changed</code>  
<dd><p>Non-zero if the option has changed (valid in the 
			OptionNotify callback).</p>
	  <dt><code>gchar	*backup;</code>	
<dd><p>Copy of value to Revert to </p>
</dl>

<dl>
<p>The other members are used when implementing new widget types.
      <dt><code>GtkWidget *widget;</code>	
<dd><p>Widget that stores the value</p>
      <dt><code>void (*update_widget)(Option *option);</code> 
<dd><p>Call to set value</p>
      <dt><code>gchar *(*read_widget)(Option *option);</code> 
<dd><p>Call to read value</p>
</dl>
</p>

      <dt><code>typedef void OptionNotify(void);</code>

<dd><p>Type of function called when options changed (see option_add_notify() below).
</p>

      <dt><code>typedef GList * (*OptionBuildFn)(Option *option, xmlNode *node, gchar *label);</code>

<dd><p>Type of function used to build widgets (see option_register_widget()
below) for the options window.  option is the option for which the
widget is used.  node is the XML node from the Options.xml file
describing the widget.  label is the label property from the element,
to be used as a label.  Returns a list of widgets to be added to the
window.
</p>

      <dt><code>void options_init(const char *project);</code>

<dd><p>Called to initialize options system.  Must be called after choices_init(), but 
before any other function in the options system.  project is the name of the 
project and is passed to choices functions.
</p>

      <dt><code>void option_register_widget(char *name, OptionBuildFn builder);</code>

<dd><p>Registers a new widget type.  name is the name of the XML element in the 
Options.xml file.  builder is the function used to build the widget.  
Pre-defined widget types include:
<ul>
	<li>label
	<li>spacer
	<li>frame
	<li>toggle
	<li>slider
	<li>entry
	<li>numentry
	<li>radio-group
	<li>colour
	<li>menu
	<li>font
</ul>
</p>

      <dt><code>void option_check_widget(Option *option);</code>

<dd><p>This is called when the widget's value is modified by the user.
Reads the new value of the widget into the option and calls
the notify callbacks.
</p>

      <dt><code>void option_add_int(Option *option, const gchar *key, int value);</code>

<dd><p>Adds a new option to hold integer values.
</p>

      <dt><code>void option_add_string(Option *option, const gchar *key, const gchar *value);</code>

<dd><p>Adds a new option to hold string values, including fonts and colours.
</p>

      <dt><code>void options_notify(void);</code>

<dd><p>Inform watching functions that options have changed.
</p>

      <dt><code>void option_add_notify(OptionNotify *callback);</code>

<dd><p>Add a callback to be called when options have changed.
</p>

      <dt><code>GtkWidget *options_show(void);</code>

<dd><p>Show options window.  Returns the window widget (you don't
normally need this), NULL if already open.

This causes the $APP_DIR/Options.xml file to be parsed.  This is an XML file containing
an 'options' element.  This in turn contains 1 or more 'section' element,
each with a 'title' property and containing one or more widgets to be built.
The 'section' elements can be nested.</p>

<p>Widgets available by default (see option_register_widget() for
	  more) are:
<dl>
  <dt><code>label help=int</code>
	<dd><p>A label</p>
  <dt><code>hbox [label=str]</code>
  <dt><code>vbox [label=str]</code>
  <dt><code>spacer</code>
  <dt><code>frame label=str</code>
	<dd><p>Container for other objects</p>
  <dt><code>section title=str</code>
	<dd><p>Groups options, can be nested.</p>

  <dt><code>toggle name=str label=str</code>
	<dd><p>Simple on/off switch</p>
  <dt><code>slider name=str label=str min=int max=int fixed=bool showvalue=bool [end=str]</code>
	  <dd><p>Range of ints.  <var>fixed</var> is fixed width.  If <var>showvalue</var> then current
	      value shown.  <var>end</var> is label after slider widget</p>
  <dt><code>entry name=str label=str</code>
	<dd><p>Text entry</p>
  <dt><code>numentry name=str label=str min=int max=int step=int width=int [unit=str]</code>
	  <dd><p>Numeric entry.  <var>width</var> is number of digits.  <var>unit</var> is text to right
	of widget (units indicator).</p>
  <dt><code>radio-group name=str label=str [columns=int]</code>
	<dd><p>List of exclusive options.  Must contain radio elements</p>
  <dt><code>radio label=str value=str</code>
	<dd><p>Option for a radio group</p>
  <dt><code>colour name=str label=str</code>
	<dd><p>Button for colour selector</p>
  <dt><code>menu name=str label=str</code>
	<dd><p>Option menu.  Must contain 'item' elements.</p>
  <dt><code>item label=str value=str</code>
	<dd><p>Option for an option menu</p>
  <dt><code>font name=str label=str override=int</code>
	  <dd><p>Button for font selector.  If <var>override</var>, adds a checkbox to enable the
	font.</p>
<dl>
</p>
</dl>

    <hr>
    <address><a href="mailto:stephen@kerofin.demon.co.uk">Stephen Watson</a></address>
<!-- Created: Tue Nov 26 10:46:50 GMT 2002 -->
<!-- hhmts start -->
Last modified: Sat Nov 29 13:29:09 GMT 2003
<!-- hhmts end -->
  </body>
</html>

