#!/usr/bin/env python
#
# $Id: AppRun,v 1.27 2006/04/29 10:22:22 stephen Exp $

import os, sys
import time

import findrox; findrox.version(2, 0, 2)
import rox, rox.choices, rox.options, rox.processes, rox.mime
import gobject

import urlparse, urllib

import dclient

__builtins__._ = rox.i18n.translation(os.path.join(rox.app_dir, 'Messages'))

real_install='%s/AppRun "$1"' % rox.app_dir

rox.setup_app_options('Fetch', site='kerofin.demon.co.uk')

allow_pw_change=rox.options.Option('allow_pw_change', True)
wait_for=rox.options.Option('wait_for', 3)
use_dl_manager=rox.options.Option('use_dl_manager', False)
block_size=rox.options.Option('block_size', 8192)
update_title=rox.options.Option('update_title', True)
install_path=rox.options.Option('install_path', real_install)

def revert_install_path():
    if install_path.has_changed and install_path.value!=real_install:
        install_path.value=real_install

rox.app_options.add_notify(revert_install_path)

rox.app_options.notify()

#bsize=4096
#stimeo=5*60
tsuf='.fetching'
delay=500

unknown_type=rox.mime.lookup('text/plain')
html_type=rox.mime.lookup('text/html')

rox.mime.install_mime_info('Fetch',
                           os.path.join(rox.app_dir, 'Fetch-mimeinfo.xml'))

def get_filename(url):
    scheme, location, path, query, fragment=urlparse.urlsplit(url)
    base=os.path.basename(path)
    if '%' in base:
        base=urllib.unquote(base)
    if not base:
        base='index.html'
    fname=base
    num=1
    while os.access(fname, os.F_OK) or os.access(fname+tsuf, os.F_OK):
        try:
            dot=base.index('.')
        except ValueError:
            dot=-1
        if dot>=0:
            fname=base[:dot]+('-%d' % num)+base[dot:]
        else:
            fname=base+'-%d' % num
        
        num+=1
        
    return fname

class FetchWindow(rox.Dialog):
    def __init__(self, url, target=None):
        self.url=url
        scheme, location, path, query, fragment=urlparse.urlsplit(url)
        self.host=location
        if not target:
            target=get_filename(url)
        self.target=target+tsuf
        file(self.target, 'w').close()
        self.real_target=target

        self.count=None
        self.start_time=None
        self.last_time=None
        self.size=0
        self.con=None
        self.bad_fetch=0 # 1=maybe, 2=yes
        self.stype=unknown_type
        self.dl_man=None
        self.wtag=0
        self.proc=None
        self.kill_proc=False

        self.percent=-1
        
        rox.Dialog.__init__(self)
        self.set_title(self.url)
        self.add_button(rox.g.STOCK_CANCEL, rox.g.RESPONSE_CANCEL)
        self.connect('response', self.do_response)

        vbox=self.vbox

        table=rox.g.Table(9, 3)
        vbox.pack_start(table, padding=4)

        line=0
        l=rox.g.Label(_('<b>Source</b>'))
        l.set_use_markup(True)
        l.set_alignment(1., 0.5)
        table.attach(l, 0, 1, line, line+1, xpadding=2)
        l=rox.g.Label(self.url)
        l.set_line_wrap(True)
        l.set_alignment(0., 0.5)
        table.attach(l, 2, 3, line, line+1, xpadding=2)

        line+=1
        l=rox.g.Label(_('<b>Size</b>'))
        l.set_use_markup(True)
        l.set_alignment(1., 0.5)
        table.attach(l, 0, 1, line, line+1, xpadding=2)
        l=rox.g.Label('')
        l.set_alignment(0., 0.5)
        table.attach(l, 2, 3, line, line+1, xpadding=2)
        self.size_l=l

        line+=1
        l=rox.g.Label(_('<b>Server Type</b>'))
        l.set_use_markup(True)
        l.set_alignment(1., 0.5)
        table.attach(l, 0, 1, line, line+1, xpadding=2)
        self.stype_icon=rox.g.Image()
        table.attach(self.stype_icon, 1, 2, line, line+1, xpadding=2)
        l=rox.g.Label('')
        l.set_alignment(0., 0.5)
        table.attach(l, 2, 3, line, line+1, xpadding=2)
        self.type_l=l

        line+=1
        l=rox.g.Label(_('<b>Local Type</b>'))
        l.set_use_markup(True)
        l.set_alignment(1., 0.5)
        table.attach(l, 0, 1, line, line+1, xpadding=2)
        self.ltype_icon=rox.g.Image()
        ltype=rox.mime.get_type_by_name(self.real_target)
        if ltype:
            icon=ltype.get_icon(rox.mime.ICON_SIZE_SMALL)
            if icon:
                self.ltype_icon.set_from_pixbuf(icon)
            icon=ltype.get_icon(rox.mime.ICON_SIZE_LARGE)
            if icon:
                self.set_icon(icon)
        self.ltype=ltype
        table.attach(self.ltype_icon, 1, 2, line, line+1, xpadding=2)
        l=rox.g.Label(str(ltype))
        l.set_alignment(0., 0.5)
        table.attach(l, 2, 3, line, line+1, xpadding=2)
        self.ltype_l=l

        line+=1
        l=rox.g.Label(_('<b>Download to</b>'))
        l.set_use_markup(True)
        l.set_alignment(1., 0.5)
        table.attach(l, 0, 1, line, line+1, xpadding=2)
        l=rox.g.Label(os.getcwd()+'/')
        l.set_alignment(0., 0.5)
        table.attach(l, 2, 3, line, line+1, xpadding=2)
        line+=1
        l=rox.g.Label(self.real_target)
        l.set_alignment(0., 0.5)
        table.attach(l, 2, 3, line, line+1, xpadding=2)

        line+=1
        l=rox.g.Label(_('<b>Bytes fetched</b>'))
        l.set_use_markup(True)
        l.set_alignment(1., 0.5)
        table.attach(l, 0, 1, line, line+1, xpadding=2)
        l=rox.g.Label('')
        l.set_alignment(0., 0.5)
        table.attach(l, 2, 3, line, line+1, xpadding=2)
        self.fetched_l=l

        line+=1
        l=rox.g.Label(_('<b>Estimated time</b>'))
        l.set_use_markup(True)
        l.set_alignment(1., 0.5)
        table.attach(l, 0, 1, line, line+1, xpadding=2)
        l=rox.g.Label('')
        l.set_alignment(0., 0.5)
        table.attach(l, 2, 3, line, line+1, xpadding=2)
        self.etime=l

        line+=1
        l=rox.g.Label(_('<b>Speed</b>'))
        l.set_use_markup(True)
        l.set_alignment(1., 0.5)
        table.attach(l, 0, 1, line, line+1, xpadding=2)
        l=rox.g.Label('')
        l.set_alignment(0., 0.5)
        table.attach(l, 2, 3, line, line+1, xpadding=2)
        self.speed=l

        line+=1
        self.msg1=rox.g.Label('')
        self.msg1.set_line_wrap(True)
        table.attach(self.msg1, 0, 3, line, line+1)

        line+=1
        self.prog=rox.g.ProgressBar()
        table.attach(self.prog, 0, 3, line, line+1)

        self.connect('delete_event', self.delete_event)
        gobject.timeout_add(delay, self.idle_update)

        self.show_all()
        self.start()

    def do_response(self, *unused):
        #print self.dl_man
        self.do_cancel(_('Cancelled'))
        if self.proc:
            self.kill_proc=True
            #print >> sys.stderr, self, unused
            self.proc.kill()
        msg=_('Fetch of %s cancelled') % self.url
        if self.count:
            msg+=_(', %d bytes ') % self.count
            if self.size:
                msg+='(%d%%) ' % int(100.*self.count/self.size)
            msg+=_('in %s') % self.target
        msg+=_('.')
        #print >> sys.stderr, 'Report cancel status'
        rox.info(msg)
        #print >> sys.stderr, 'Exit now'
        sys.exit(0)

    def idle_update(self, *unused):
        #print 'in idle_update', self.last_time
        if self.last_time:
            now=time.time()
            if now-self.last_time>60:
                self.message(_('Stalled? Last update %ds ago') %
                             int(now-self.last_time))
            #print now, now-self.last_time

        #print 'leaving'
        return True

    def delete_event(self, *unused):
        #print 'delete_event', self, unused
        #print rox._toplevel_windows
        self.close()
        #print rox._toplevel_windows
        
    def message(self, text):
        self.msg1.set_text(text)

    def percent_done(self, size, total):
        if self.prog is None:
            return
        if size>total:
            val=1.
        elif total>0:
            val=float(size)/total
        else:
            self.active()
            return
        self.prog.set_fraction(val)
        percent=int(val*100)
        if self.percent!=percent:
            self.percent=percent
            self.prog.set_text('%d%%' % (val*100))
            if update_title.int_value:
                self.set_title('%d%% %s' % (val*100, self.real_target))

        if self.start_time and total>0 and size>0:
            now=time.time()
            elapsed=now-self.start_time
            etotal=elapsed*total/size
            eleft=etotal-elapsed
            #print elapsed, etotal, eleft
            secs=int(eleft)
            hours=int(secs/3600)
            secs-=hours*3600
            mins=int(secs/60)
            secs-=mins*60
            if eleft<=0:
                tstr=_('Done')
            elif hours>0:
                tstr='%d:%02d:%02d' % (hours, mins, secs)
            else:
                tstr='%02d:%02d' % (mins, secs)
            self.etime.set_text(tstr)

            if elapsed>0:
                speed=size/elapsed/1024
                self.speed.set_text('%2.1f KB/s' % speed)
            
    def active(self):
        self.prog.set_text('')
        self.prog.pulse()

    def unwait(self):
        if self.wtag:
            gobject.source_remove(self.wtag)
            self.wtag=None

    def do_cancel(self, why):
        if self.dl_man:
            self.dl_man.cancel(why)
            self.dl_man=None
        self.unwait()

    def close(self):
        #print 'close'
        self.do_cancel(_('Window closed'))
        if self.proc:
            try:
                #print >>sys.stderr, "window closed"
                self.kill_proc=True
                self.proc.kill()
            except:
                pass
            self.proc=None
        self.hide()
        self.destroy()
        self.prog=None
        #rox.toplevel_unref()

    def set_server_type(self, stype_name):
        self.type_l.set_text(stype_name)
        if stype_name.find(';')>=0:
            stype_name, para=stype_name.split(';', 1)
        try:
            stype=rox.mime.lookup(stype_name.strip())
        except:
            stype=unknown_type
        self.stype=stype
        if stype:
            icon=stype.get_icon(rox.mime.ICON_SIZE_SMALL)
            if icon:
                self.stype_icon.set_from_pixbuf(icon)
            if stype!=unknown_type:
                icon=stype.get_icon(rox.mime.ICON_SIZE_LARGE)
                if icon:
                    self.set_icon(icon)

            if stype!=self.ltype and stype==html_type:
                self.bad_fetch=1
        

    def read_some(self, source, condition, *unused):
        #print source, condition, unused
        #print self.con

        self.last_time=time.time()
        self.message(_('Downloading'))

        data=''
        while True:
            try:
                c=self.con.read(1)
            except ValueError:
                break
            data+=c
            #print 'Read',data
            if c=='\n':
                break
        #print data,
        #self.count+=len(data)
        if data:
            #print data
            try:
                code, arg=data.split('=', 1)
            except ValueError:
                code='m'
                arg=data
                
            if code=='m':
                self.message(arg.strip())
            elif code=='t':
                self.set_server_type(arg.strip())
            elif code=='s':
                self.size = int(arg)
                self.report(0, self.size)
            elif code=='n':
                self.count=int(arg)
                if self.count==0:
                    self.start_time=time.time()
                self.report(self.count, self.size)
            elif code=='c':
                self.finished()
                return False
            elif code=='x':
                self.message(_('Helper process crashed: %s') % arg.strip())
                self.finished()
                return False
            
            return True

        self.finished()
        return False
        
    def start(self):
        if use_dl_manager.int_value:
            try:
                self.message(_("Connecting to DownloadManager"))
                self.dl_man=dclient.connect()
            except:
                self.message(_("Could not connect to DownloadManager"))

        if self.dl_man:
            self.acquire()
        else:
            self.real_start()

    def on_slot_available(self, interface, signal_name, service, path, message):
        #print interface, signal_name, service, path, message
        if self.dl_man:
            if not self.waiting():
                self.unwait()
                
        
    def acquire(self):
        self.dl_man.register(self.on_slot_available)
        self.wtag=gobject.timeout_add(delay, self.waiting)

    def waiting(self):
        if self.proc:
            return False
        if not self.dl_man:
            self.real_start()
            return False

        try:
            go=self.dl_man.acquire(self.host,
                                   os.path.basename(self.real_target),
                                   block=False)
        except dclient.DMNotRunning:
            go=True
        except dclient.DMNoAnswer:
            go=True
        except:
            go=False
            
            
        if go:
            try:
                self.real_start()
            except:
                rox.report_exception()
            return False

        n=self.dl_man.getQueueSize()
        self.message(_('Waiting, %d in queue') % n)

        return True

    def real_start(self):
        r, w=os.pipe()
        self.con=os.fdopen(r, 'r', 1)
        self.proc=rox.processes.PipeThroughCommand(
            ('python', rox.app_dir+'/fetch.py', self.url, self.target),
            None, os.fdopen(w, 'w', 1))

        gobject.io_add_watch(self.con.fileno(), gobject.IO_IN,
                        self.read_some)

        try:
            self.proc.wait()
        except rox.processes.ChildKilled:
            pass
            
        #print 'done waiting'
        self.proc=None
        #self.finished()
        
    def report(self, nb, tsize):
        #print 'report', self, nb, tsize
        if nb>4<<20:
            tstr='%d bytes (%d MB)' % (nb, nb>>20)
        elif nb>4<<10:
            tstr='%d bytes (%d KB)' % (nb, nb>>10)
        else:
            tstr='%d bytes' % nb
            
        self.fetched_l.set_text(tstr)

        if tsize>0:
            self.percent_done(nb, tsize)
            if tsize>4<<20:
                tstr='%d bytes (%d MB)' % (tsize, tsize>>20)
            elif tsize>4<<10:
                tstr='%d bytes (%d KB)' % (tsize, tsize>>10)
            else:
                tstr='%d bytes' % tsize
            self.size_l.set_text(tstr)
        else:
            self.active()

        if self.dl_man:
            self.dl_man.update(nb, tsize)

    def finished(self):
        if self.dl_man:
            self.dl_man.done()
            self.dl_man=None
        try:
            os.rename(self.target, self.real_target)
        except OSError:
            rox.info(_('Rename failed, data left in temporary file %s') %
                     self.target)
        try:
            self.con.close()
        except:
            pass
        t=wait_for.int_value*1000
        mess=_('Done')
        if self.ltype!=self.stype:
            if self.stype==unknown_type:
                mess=_('Done (server did not know type)')
            elif self.stype==html_type:
                mess=_('Server may have sent error')
                t*=3
            else:
                mess=_('Done.  Warning: type mismatch')
                t*=3
        self.message(mess)
        gobject.timeout_add(t, self.close)
        
def main():
    if len(sys.argv)==1 or (len(sys.argv)==2 and sys.argv[1]=='-o'):
         rox.edit_options()
         rox.mainloop()
        
    else:
        url=sys.argv[1]
        local=None
        if len(sys.argv)>2:
            local=sys.argv[2]
        try:
            win=FetchWindow(url, local)
            rox.mainloop()
        except:
            rox.report_exception()

if __name__=='__main__':
    main()
